/* monad.hpp
The world's most simple C++ monad
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: June 2015


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_SPINLOCK_MONAD_HPP
#define BOOST_SPINLOCK_MONAD_HPP

#include "tribool.hpp"

// For some odd reason, VS2015 really hates to do much inlining unless forced
#ifdef _MSC_VER
//# pragma inline_depth(255)
//# pragma inline_recursion(on)
# define BOOST_SPINLOCK_FUTURE_CONSTEXPR BOOST_FORCEINLINE
# define BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR BOOST_FORCEINLINE
# define BOOST_SPINLOCK_FUTURE_MSVC_HELP BOOST_FORCEINLINE
#else
# define BOOST_SPINLOCK_FUTURE_CONSTEXPR BOOST_CONSTEXPR
# define BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR BOOST_CXX14_CONSTEXPR
# define BOOST_SPINLOCK_FUTURE_MSVC_HELP 
#endif

/*! \file monad.hpp
\brief Provides a lightweight simple monadic value transport

\headerfile include/boost/spinlock/monad.hpp ""
*/

/*! \defgroup monad Configurable lightweight simple monadic value transport with the same semantics and API as a future
\ingroup future_promise

Predefined basic_monad implementations:
<dl>
  <dt>`monad<R>`</dt>
    <dd>Can hold a fixed variant list of empty, a type `R`, a lightweight `std::error_code` or a
heavier `std::exception_ptr` at a space cost of `max(24, sizeof(R)+8)`. This corresponds to `tribool::unknown`,
`tribool::true_`, `tribool::false_` and `tribool::false_` respectively.</dd>
  <dt>`result<R>`</dt>
    <dd>Can hold a fixed variant list of empty, a type `R` or a lightweight `std::error_code` at a
space cost of `max(24, sizeof(R)+8)`. This corresponds to `tribool::unknown`, `tribool::true_` and
`tribool::false_` respectively. This specialisation looks deliberately like Rust's `Result<T>`.</dd>
  <dt>`option<R>`</dt>
    <dd>Can hold a fixed variant list of empty or a type `R` at a space cost of `sizeof(value_storage<R>)`
which is usually `sizeof(R)+8`, but may be smaller if `value_storage<R>` is specialised e.g.
`sizeof(option<char>)` is just two bytes. This corresponds to `tribool::unknown` and `tribool::true_`
respectively. This specialisation looks deliberately like Rust's `Option<T>`.</dd>
</dl>

Features:

- Very lightweight on build times and run times up to the point of zero execution cost and just an eight
byte space overhead. See below for benchmarks. Requires min clang 3.2, GCC 4.8 or VS2015.
- Just enough monad, nothing more, nothing fancy. Replicates the future API, so if you know how to
use a future you already know how to use this.
- Enables convenient and easy all-`noexcept` coding and design, giving you powerful error handling facilities
with automatic exception safety.
- Can replace most uses of `optional<T>`.
- Deep integration with lightweight future-promise (i.e. async monadic programming) also in this library which
subclasses these monads. See \ref future_promise.
- Comprehensive unit testing and validation suite.
- Mirrors `noexcept` of type R.
- Type R can have no default constructor, move nor copy.
- Works inside a STL container, and type R can be a STL container.
  - No comparison operations nor hashing is provided, deliberately to keep things simple.

## Notes: ##

As `monad<R>`, `result<R>` and `option<R>` are all just `basic_monad` with different implementation
policies, wherever we refer to `monad<R>` we mean those three specialisations as well.

Something which might surprise people is that:

\code
monad<std::string> a("niall");
monad<std::string> b(std::move(a));
BOOST_CHECK(a.has_value());  // true
\endcode

Moving a monad does a move of its underlying contents, so any contents remain at whatever
the move constructor for that content leaves things. In other words, a moved from monad
does not become empty, if you want that then call clear().

So long as you avoid the exception_type code paths (`result<R>`, `option<R>`), this implementation will be
ideally reduced to as few assembler instructions as possible by most recent compilers [1]
which can include exactly zero assembler instructions output. This monad is therefore
identical in terms of execution overhead to using the R type you specify directly - you
get the monadic functionality totally free of execution overhead where the compiler is able
to reduce it to such.

A similar thing applies to error_type which is a lightweight implementation on most
systems. An exception is on VS2015 as the lvalue reference to system_category appears
to be constructed via thread safe once routine called "Immortalize", so when you
construct an error_type on MSVC you'll force a memory synchronisation during the constructor
only. error_types are very cheap to pass around though as they are but an integer and a lvalue ref,
though I see that on GCC and clang 16 bytes is always copied around instead of completely
eliding the copy.

exception_type is also pretty good on anything but MSVC, though never zero assembler
instructions. As soon as an exception_type \em could be created, you'll force out about twenty
instructions most of which won't be executed in practice. Unfortunately, MSVC churns out
about 2000 assembler instructions as soon as you might touch an exception_type, I've raised
this with Microsoft and it looks to be hard for them to fix due to backwards compatibility
reasons.

[1]: GCC 5.1 does a perfect job, VS2015 does a good job, clang 3.7 not so great. See next section.

## Complexity guarantees ##

These x64 opcode guarantees are empirically determined by the unit test suite, and the per-commit
CI testing will fail if they suddenly are exceeded. The maximum is calculated by taking a monad
in from a non-visible source where the compiler has to generate code paths to handle an unknown
input state, whereas the minimum is calculated by setting a monad's state in view of the compiler's
optimiser such that it can usually completely elide opcodes generated (though note that varies
enormously by compiler to the extent that the known code generates more opcodes than the unknown code). All monads are `monad<int>`.

### `monad<R>`: ###
<dl>
 <dt>clang 3.7</dt>
  <dd>51 opcodes <= Value transport <= 32 opcodes<br></dd>
  <dd>6 opcodes <= Error transport <= 50 opcodes<br></dd>
  <dd>54 opcodes <= Exception transport <= 35 opcodes<br></dd>  
  <dd>55 opcodes <= next() <= 76 opcodes<br></dd>
  <dd>4 opcodes <= bind() <= 42 opcodes</dd>
 <dt>GCC 5.1</dt>
  <dd>1 opcodes <= Value transport <= 50 opcodes<br></dd>
  <dd>8 opcodes <= Error transport <= 37 opcodes<br></dd>
  <dd>27 opcodes <= Exception transport <= 151 opcodes<br></dd>
  <dd>4 opcodes <= next() <= 89 opcodes<br></dd>
  <dd>5 opcodes <= bind() <= 44 opcodes</dd>
 <dt>VS2015</dt>
  <dd>4 opcodes <= Value transport <= 1879 opcodes<br></dd>
  <dd>6 opcodes <= Error transport <= 159 opcodes<br></dd>
  <dd>1973 opcodes <= Exception transport <= 1940 opcodes<br></dd>
  <dd>1981 opcodes <= next() <= 1982 opcodes<br></dd>
  <dd>103 opcodes <= bind() <= 104 opcodes</dd>
</dl>

### `result<R>`: ###
<dl>
 <dt>clang 3.7</dt>
  <dd>2 opcodes <= Value transport <= 49 opcodes<br></dd>
  <dd>4 opcodes <= next() <= 56 opcodes<br></dd>
 <dt>GCC 5.1</dt>
  <dd>1 opcodes <= Value transport <= 32 opcodes<br></dd>
  <dd>4 opcodes <= next() <= 52 opcodes<br></dd>
 <dt>VS2015</dt>
  <dd>4 opcodes <= Value transport <= 1848 opcodes<br></dd>
  <dd>1918 opcodes <= next() <= 1919 opcodes<br></dd>
</dl>

### `option<R>`: ###
<dl>
 <dt>clang 3.7</dt>
  <dd>2 opcodes <= Value transport <= 26 opcodes<br></dd>
  <dd>5 opcodes <= next() <= 37 opcodes<br></dd>
 <dt>GCC 5.1</dt>
  <dd>1 opcodes <= Value transport <= 9 opcodes<br></dd>
  <dd>4 opcodes <= next() <= 27 opcodes<br></dd>
 <dt>VS2015</dt>
  <dd>4 opcodes <= Value transport <= 117 opcodes<br></dd>
  <dd>185 opcodes <= next() <= 186 opcodes<br></dd>
</dl>

Despite the opcode spillage, performance is \b excellent on all compilers. Modern optimisers do a really
great job at reaching tens of CPU cycle overhead with this monad design.

## Examples ##

\snippet unittests.cpp monad_example

### As an alternative to `optional<T>` ###

Something not so obvious is that this monad can have an empty state, and therefore
can stand in for `optional<T>` like this:

\snippet unittests.cpp optional_example

The API is actually not too distant from `optional<T>`, so with a bit of regex find and replace
you could use `option<T>` instead.

The need for `monad<T>` to be able to be empty was to make exception throws by T during copy and move
construction lightweight. If that happens, the monad always has empty state afterwards.

## Supplying your own implementations of `basic_monad<T>` ##
To do this, simply supply a policy type of the following form:
\snippet monad.hpp monad_policy
*/


BOOST_SPINLOCK_V1_NAMESPACE_BEGIN

namespace traits
{
  namespace detail
  {
    // Gets the return type of F(A), returning a not_well_formed type if not well formed
    template<class F, class A> struct get_return_type
    {
      struct not_well_formed {};
      template<class _F, class _A> static not_well_formed test(...);
      template<class _F, class _A> static auto test(_F &&f) noexcept(noexcept(f(std::declval<_A>()))) -> decltype(f(std::declval<_A>()));
      using type = decltype(test<F, A>(std::declval<F>()));
      BOOST_STATIC_CONSTEXPR bool is_noexcept = noexcept(test<F, A>(std::declval<F>()));
    };

    // Without Expression SFINAE (VS2015), I actually don't know of a better way :(
    template<class T, class Arg> class has_call_operator2
    {
      struct Fallback { int operator()(Arg); };
      struct Derived : T, Fallback { };

      template<typename U, U> struct Check;

      typedef char ArrayOfOne[1], ArrayOfTwo[2];

      template<typename U> static ArrayOfOne & func(Check<int Fallback::*, &U::operator()> *);
      template<typename U> static ArrayOfTwo & func(...);

    public:
      BOOST_STATIC_CONSTEXPR bool value = sizeof(func<Derived>(0)) == 2;
    };
    template <bool enable, typename F, typename Arg> struct has_call_operator : public std::false_type {};
    template <typename F, typename Arg> struct has_call_operator<true, F, Arg> : public has_call_operator2<F, typename get_return_type<F, Arg>::type(Arg)>{};

    template<bool _is_move, bool _is_lvalue, bool _is_auto, typename T=void> struct arg_form
    {
      BOOST_STATIC_CONSTEXPR bool is_rvalue = _is_move;
      BOOST_STATIC_CONSTEXPR bool is_lvalue = _is_lvalue;
      BOOST_STATIC_CONSTEXPR bool is_auto = _is_auto;
      using non_auto_type = T;
    };

    template<int R> struct rank : rank<R - 1> { static_assert(R > 0, ""); };
    template<> struct rank<0> {};

    template<bool is_class, class F, class A> struct call_operator_argument_form
    {
    };
    template<class F, class A> struct call_operator_argument_form<true, F, A>
    {
      using return_type = typename get_return_type<F, A>::type;
      using arg_type = typename std::decay<A>::type;

      static arg_form<false, true , true> test(return_type(F::*)(const arg_type&)      , rank<1>);
      static arg_form<false, true , true> test(return_type(F::*)(arg_type&)            , rank<2>);
      static arg_form<true , false, true> test(return_type(F::*)(arg_type&&)           , rank<3>);
      static arg_form<false, false, true> test(return_type(F::*)(arg_type)             , rank<4>);
      static arg_form<false, true , true> test(return_type(F::*)(const arg_type&) const, rank<5>);
      static arg_form<false, true , true> test(return_type(F::*)(arg_type&)       const, rank<6>);
      static arg_form<true , false, true> test(return_type(F::*)(arg_type&&)      const, rank<7>);
      static arg_form<false, false, true> test(return_type(F::*)(arg_type)        const, rank<8>);

      template<class T> static arg_form<false, false, false, T> test(return_type(F::*)(T)             , rank<9>);
      template<class T> static arg_form<false, true , false, T> test(return_type(F::*)(T&)            , rank<10>);
      template<class T> static arg_form<true , false, false, T> test(return_type(F::*)(T&&)           , rank<11>);
      template<class T> static arg_form<false, false, false, T> test(return_type(F::*)(T)        const, rank<12>);
      template<class T> static arg_form<false, true , false, T> test(return_type(F::*)(T&)       const, rank<13>);
      template<class T> static arg_form<true , false, false, T> test(return_type(F::*)(T&&)      const, rank<14>);

      using result = decltype(test(&F::operator(), rank<15>()));

      BOOST_STATIC_CONSTEXPR bool is_rvalue = result::is_rvalue;
      BOOST_STATIC_CONSTEXPR bool is_lvalue = result::is_lvalue;
      BOOST_STATIC_CONSTEXPR bool is_auto = result::is_auto;
      using type = typename result::non_auto_type;
    };

    template<bool is_function, class F, class A> struct function_argument_form
    {
    };
    template<class F, class A> struct function_argument_form<true, F, A>
    {
      using return_type = typename get_return_type<F, A>::type;
      using arg_type = typename std::decay<A>::type;

      static arg_form<false, true , true> test(return_type(*)(const arg_type&)      , rank<1>);
      static arg_form<false, true , true> test(return_type(*)(arg_type&)            , rank<2>);
      static arg_form<true , false, true> test(return_type(*)(arg_type&&)           , rank<3>);
      static arg_form<false, false, true> test(return_type(*)(arg_type)             , rank<4>);

      template<class T> static arg_form<false, false, false, T> test(return_type(*)(T)             , rank<5>);
      template<class T> static arg_form<false, true , false, T> test(return_type(*)(T&)            , rank<6>);
      template<class T> static arg_form<true , false, false, T> test(return_type(*)(T&&)           , rank<7>);

      using result = decltype(test(F(), rank<10>()));

      BOOST_STATIC_CONSTEXPR bool is_rvalue = result::is_rvalue;
      BOOST_STATIC_CONSTEXPR bool is_lvalue = result::is_lvalue;
      BOOST_STATIC_CONSTEXPR bool is_auto = result::is_auto;
      using type = typename result::non_auto_type;
    };

  }

  //! \brief Is the callable F called with Arg well formed?
  template<class F, class A> struct is_callable_is_well_formed
  {
    using return_type = detail::get_return_type<F, A>;
    //! \brief The type returned by the callable F when called with Arg
    using type = typename return_type::type;
    //! \brief Whether the call with Arg is well formed
    BOOST_STATIC_CONSTEXPR bool value = !std::is_same<type, typename return_type::not_well_formed>::value;
    //! \brief Whether the call with Arg is noexcept
    BOOST_STATIC_CONSTEXPR bool is_noexcept = return_type::is_noexcept;
  };

  //! \brief Is F a class type and does it have a call operator callable with Arg?
  template<typename F, typename Arg> struct has_call_operator
    : public detail::has_call_operator<std::is_class<F>::value, F, Arg>
  { };

  namespace detail
  {
    template<bool enable, class F, class A> struct callable_argument_traits
    {
      //! \brief Is the callable F called with Arg well formed?
      BOOST_STATIC_CONSTEXPR bool valid = false;
      //! \brief Is the arg a rvalue ref?
      BOOST_STATIC_CONSTEXPR bool is_rvalue = false;
      //! \brief Is the arg a lvalue ref?
      BOOST_STATIC_CONSTEXPR bool is_lvalue = false;
      //! \brief Is the arg a templated arg?
      BOOST_STATIC_CONSTEXPR bool is_auto = false;
      //! \brief If the arg is not a templated arg, it is this type
      using type = void;
    };
    template<class F, class A> struct callable_argument_traits<true, F, A>
      : public std::conditional<!std::is_function<F>::value && has_call_operator<std::is_class<F>::value, F, A>::value,
        detail::call_operator_argument_form<true, F, A>,
        detail::function_argument_form<true, F, A>
      >::type
    {
      BOOST_STATIC_CONSTEXPR bool valid = true;
    };
  }

  /*! \brief If callable F were to be called with A, tell me about the call.
  */
  template<class F, class A> struct callable_argument_traits
    : public detail::callable_argument_traits<is_callable_is_well_formed<F, A>::value, F, A>
  {
    //! The type returned by the callable when called with A
    using return_type=typename is_callable_is_well_formed<F, A>::type;
  };

}

namespace lightweight_futures
{

  //! \brief Enumeration of the ways in which a monad operation may fail \ingroup monad
  enum class monad_errc {
    already_set = 1,        //!< Attempt to store a value into the monad twice
    no_state = 2,           //!< Attempt to use without a state
    exception_present = 3,  //!< Attempt to fetch an error state when the monad is in an exceptioned state
  };

  namespace detail
  {
    class monad_category : public std::error_category
    {
    public:
      virtual const char *name() const noexcept { return "basic_monad"; }
      virtual std::string message(int c) const
      {
        switch(c)
        {
          case 1: return "already set";
          case 2: return "no state";
          case 3: return "exception present";
          default: return "unknown";
        }
      }
    };
  }

  /*! \brief Returns a reference to a monad error category. Note the address
  of one of these may not be constant throughout the process as per the ISO spec.
  \ingroup monad
  */
  inline const detail::monad_category &monad_category()
  {
    static detail::monad_category c;
    return c;
  }

  //! \brief A monad exception object \ingroup monad
  class BOOST_SYMBOL_VISIBLE monad_error : public std::logic_error
  {
    std::error_code _ec;
  public:
    monad_error(std::error_code ec) : std::logic_error(ec.message()), _ec(std::move(ec)) { }
    const std::error_code &code() const noexcept { return _ec; }
  };

  //! \brief ADL looked up by the STL to convert a monad_errc into an error_code. \ingroup monad
  inline std::error_code make_error_code(monad_errc e)
  {
    return std::error_code(static_cast<int>(e), monad_category());
  }

  //! \brief ADL looked up by the STL to convert a monad_errc into an error_condition. \ingroup monad
  inline std::error_condition make_error_condition(monad_errc e)
  {
    return std::error_condition(static_cast<int>(e), monad_category());
  }

  template<class Impl> class basic_monad;
}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
  //! \brief Tells the STL this is an error code enum \ingroup monad
  template<> struct is_error_code_enum<BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad_errc> : std::true_type {};
  //! \brief Tells the STL this is an error condition enum \ingroup monad
  template<> struct is_error_condition_enum<BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad_errc> : std::true_type {};
}

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN
namespace lightweight_futures {
  
  using tribool::true_;
  using tribool::false_;
  using tribool::other;
  using tribool::indeterminate;
  using tribool::unknown;  

  namespace detail
  {
    // A move only capable lightweight std::function, as std::function can't handle move only callables
    template<class F> class function_ptr;
    template<class R, class... Args> class function_ptr<R(Args...)>
    {
      struct function_ptr_storage
      {
        virtual ~function_ptr_storage() { }
        virtual R operator()(Args&&... args) = 0;
      };
      template<class U> struct function_ptr_storage_impl : public function_ptr_storage
      {
        U c;
        BOOST_SPINLOCK_FUTURE_CONSTEXPR function_ptr_storage_impl(U &&_c) : c(std::move(_c)) { }
        virtual R operator()(Args &&... args) override final { return c(std::move(args)...); }
      };
      function_ptr_storage *ptr;
      template<class U> explicit function_ptr(U &&f, std::nullptr_t) : ptr(new function_ptr_storage_impl<typename std::decay<U>::type>(std::forward<U>(f))) { }
      template<class R, class U> friend inline function_ptr<R> make_function_ptr(U &&f);
    public:
      BOOST_SPINLOCK_FUTURE_CONSTEXPR function_ptr() noexcept : ptr(nullptr) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR function_ptr(function_ptr_storage *p) noexcept : ptr(p) { }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR function_ptr(function_ptr &&o) noexcept : ptr(o.ptr) { o.ptr = nullptr; }
      function_ptr &operator=(function_ptr &&o) { delete ptr; ptr = o.ptr; o.ptr = nullptr; return *this; }
      function_ptr(const function_ptr &) = delete;
      function_ptr &operator=(const function_ptr &) = delete;
      ~function_ptr() { delete ptr; }
      explicit BOOST_SPINLOCK_FUTURE_CONSTEXPR operator bool() const noexcept { return !!ptr; }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR R operator()(Args... args) const
      {
        return (*ptr)(std::move(args)...);
      }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR function_ptr_storage *get() noexcept { return ptr; }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR function_ptr_storage *release() noexcept { auto p = ptr; ptr = nullptr; return p; }
    };
    template<class R, class U> inline function_ptr<R> make_function_ptr(U &&f) { return function_ptr<R>(std::forward<U>(f), nullptr); }
  }

  /*! \class value_storage
  \tparam implementation_policy A policy type providing a `value_type`, an `error_type`, an `exception_type`, an
  `implementation_type` and a function called `bool _throw_error(monad_errc)`.
  \brief A fixed lightweight variant store for monad.
  \ingroup monad
  
  This fixed variant list of empty, a type `R`, a lightweight `error_type` or a
  heavier `exception_type` typically has a space cost of `max(24, sizeof(R)+4)`.
  
  \todo Small space specialisations for value_storage<void> and value_storage<bool> and value_storage<tribool>
  */
  template<class implementation_policy> class value_storage
  {
    // Define stand in types for when these are void. As they are private, they
    // are disabled for SFINAE and any attempt to use them yields a useful error message.
    struct no_value_type {};
    struct no_error_type {};
    struct no_exception_type {};
    struct no_pointer_type { no_pointer_type(std::nullptr_t) { } };
    template<class U, class V> using devoid = typename std::conditional<!std::is_void<U>::value, U, V>::type;
  public:
    BOOST_STATIC_CONSTEXPR bool has_value_type = !std::is_void<typename implementation_policy::value_type>::value;
    BOOST_STATIC_CONSTEXPR bool has_error_type = !std::is_void<typename implementation_policy::error_type>::value;
    BOOST_STATIC_CONSTEXPR bool has_exception_type = !std::is_void<typename implementation_policy::exception_type>::value;
    BOOST_STATIC_CONSTEXPR bool has_pointer_type = !std::is_void<typename implementation_policy::pointer_type>::value;
    typedef typename implementation_policy::implementation_type implementation_type;
    typedef devoid<typename implementation_policy::value_type, no_value_type> value_type;
    typedef devoid<typename implementation_policy::error_type, no_error_type> error_type;
    typedef devoid<typename implementation_policy::exception_type, no_exception_type> exception_type;
    typedef devoid<typename implementation_policy::pointer_type, no_pointer_type> pointer_type;
    struct Pointer_t
    {
      pointer_type pointer;        // Typically 8 bytes
      detail::function_ptr<void(pointer_type)> callable;  // Typically 8 bytes
      BOOST_SPINLOCK_FUTURE_CONSTEXPR Pointer_t(pointer_type p) : pointer(p) { }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR Pointer_t(Pointer_t &&o) noexcept : pointer(std::move(o.pointer)), callable(std::move(o.callable)) { o.pointer = nullptr; }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR Pointer_t &operator=(Pointer_t &&o) noexcept
      {
        pointer = std::move(o.pointer);
        callable = std::move(o.callable);
        o.pointer = nullptr;
        return *this;
      }
      ~Pointer_t() { pointer = nullptr; }
    };
    typedef typename std::conditional<!std::is_void<typename implementation_policy::pointer_type>::value, Pointer_t, no_pointer_type>::type Pointer;

    static_assert(!std::is_same<value_type, error_type>::value, "R and error_type cannot be the same type");
    static_assert(!std::is_same<value_type, exception_type>::value, "R and exception_type cannot be the same type");
    static_assert(!std::is_same<error_type, exception_type>::value, "error_type and exception_type cannot be the same type");

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4624)
#endif
    union
    {
      value_type value;
      error_type error;              // Often 16 bytes surprisingly
      exception_type exception;      // Typically 8 bytes
      Pointer pointer_;
    };
#ifdef _MSC_VER
#pragma warning(pop)
#endif
    enum class storage_type : unsigned char
    {
      empty,
      value,
      error,
      exception,
      pointer
    } type;

    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_constructible = std::is_nothrow_copy_constructible<value_type>::value && std::is_nothrow_copy_constructible<exception_type>::value && std::is_nothrow_copy_constructible<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_constructible = std::is_nothrow_move_constructible<value_type>::value && std::is_nothrow_move_constructible<exception_type>::value && std::is_nothrow_move_constructible<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_assignable = std::is_nothrow_copy_assignable<value_type>::value && std::is_nothrow_copy_assignable<exception_type>::value && std::is_nothrow_copy_assignable<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_assignable = std::is_nothrow_move_assignable<value_type>::value && std::is_nothrow_move_assignable<exception_type>::value && std::is_nothrow_move_assignable<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_destructible = std::is_nothrow_destructible<value_type>::value && std::is_nothrow_destructible<exception_type>::value && std::is_nothrow_destructible<error_type>::value;

#if !defined(__GNUC__) || defined(__clang__)
    /* If enabled GCC pukes during unwrap() with:
        /usr/include/c++/5/type_traits:2204:7: error: static assertion failed: declval() must not be used!
          static_assert(__declval_protector<_Tp>::__stop,
        Apparently it's a known problem in constexpr compilation, and has been for some years now.
    */
    BOOST_SPINLOCK_FUTURE_CONSTEXPR
#endif
      value_storage() noexcept : type(storage_type::empty) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value) : value(v), type(storage_type::value) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const error_type &v) noexcept(std::is_nothrow_copy_constructible<error_type>::value) : error(v), type(storage_type::error) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const exception_type &v) noexcept(std::is_nothrow_copy_constructible<exception_type>::value) : exception(v), type(storage_type::exception) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value) : value(std::move(v)), type(storage_type::value) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(error_type &&v) noexcept(std::is_nothrow_move_constructible<error_type>::value) : error(std::move(v)), type(storage_type::error) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(exception_type &&v) noexcept(std::is_nothrow_move_constructible<exception_type>::value) : exception(std::move(v)), type(storage_type::exception) { }
    struct emplace_t {};
    template<class... Args> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit value_storage(emplace_t, Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Args...>::value) : value(std::forward<Args>(args)...), type(storage_type::value) { }

    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage(const value_storage &o) noexcept(is_nothrow_copy_constructible) : type(storage_type::empty)
    {
      switch (o.type)
      {
      case storage_type::empty:
        break;
      case storage_type::value:
        new (&value) value_type(o.value);
        break;
      case storage_type::error:
        new (&error) error_type(o.error);
        break;
      case storage_type::exception:
        new (&exception) exception_type(o.exception);
        break;
      case storage_type::pointer:
        abort();  // Pointer storage only ever has move semantics
        break;
      }
      type = o.type;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage(value_storage &&o) noexcept(is_nothrow_move_constructible) : type(storage_type::empty)
    {
      switch (o.type)
      {
      case storage_type::empty:
        break;
      case storage_type::value:
        new (&value) value_type(std::move(o.value));
        break;
      case storage_type::error:
        new (&error) error_type(std::move(o.error));
        break;
      case storage_type::exception:
        new (&exception) exception_type(std::move(o.exception));
        break;
      case storage_type::pointer:
        new (&pointer_) Pointer(std::move(o.pointer_));
        break;
      }
      type = o.type;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage &operator=(const value_storage &o) noexcept(is_nothrow_destructible && is_nothrow_copy_constructible)
    {
      clear();
      new (this) value_storage(o);
      return *this;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage &operator=(value_storage &&o) noexcept(is_nothrow_destructible && is_nothrow_move_constructible)
    {
      clear();
      new (this) value_storage(std::move(o));
      return *this;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_state(value_storage &&o) noexcept(is_nothrow_destructible && is_nothrow_move_constructible)
    {
      clear();
      new (this) value_storage(std::move(o));
    }
    BOOST_SPINLOCK_FUTURE_MSVC_HELP ~value_storage() noexcept(is_nothrow_destructible) { clear(); }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void swap(value_storage &o) noexcept(is_nothrow_move_constructible)
    {
      if (type == o.type)
      {
        switch (type)
        {
        case storage_type::empty:
          break;
        case storage_type::value:
          std::swap(value, o.value);
          break;
        case storage_type::error:
          std::swap(error, o.error);
          break;
        case storage_type::exception:
          std::swap(exception, o.exception);
          break;
        case storage_type::pointer:
          std::swap(pointer_, o.pointer_);
          break;
        }
      }
      else
      {
        value_storage temp(std::move(o));
        o = std::move(*this);
        *this = std::move(temp);
      }
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void clear() noexcept(is_nothrow_destructible)
    {
      switch (type)
      {
      case storage_type::empty:
        break;
      case storage_type::value:
        value.~value_type();
        type = storage_type::empty;
        break;
      case storage_type::error:
        error.~error_type();
        type = storage_type::empty;
        break;
      case storage_type::exception:
        exception.~exception_type();
        type = storage_type::empty;
        break;
      case storage_type::pointer:
        pointer_.~Pointer();
        type = storage_type::empty;
        break;
      }
    }
    template<class U> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_value(U &&v)
    {
      assert(type == storage_type::empty);
      new (&value) value_type(std::forward<U>(v));
      type = storage_type::value;
    }
    template<class... Args> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void emplace_value(Args &&... v)
    {
      assert(type == storage_type::empty);
      new (&value) value_type(std::forward<Args>(v)...);
      type = storage_type::value;
    }
    void set_exception(exception_type e)
    {
      assert(type == storage_type::empty);
      new (&exception) exception_type(std::move(e));
      type = storage_type::exception;
    }
    // Note to self: this can't be BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR
    void set_error(error_type e)
    {
      assert(type == storage_type::empty);
      new (&error) error_type(std::move(e));
      type = storage_type::error;
    }
    // Called by future to take ownership of storage from promise
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_pointer(pointer_type f)
    {
      assert(type == storage_type::empty);
      new (&pointer_) Pointer(std::move(f));
      type = storage_type::pointer;
    }
    // Called by future to set a continuation
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_continuation(detail::function_ptr<void(pointer_type)> c)
    {
      assert(type == storage_type::pointer);
      pointer_.callable = std::move(c);
    }
  };

  namespace detail
  {
    template<class M> struct is_monad : std::false_type {};
    template<class Impl> struct is_monad<basic_monad<Impl>> : std::true_type{};
    
    // Does the monad contain a monad?
    template<class> struct is_monad_monad;
    template<class Policy> struct is_monad_monad<basic_monad<Policy>>
    {
      BOOST_STATIC_CONSTEXPR bool value=is_monad<typename basic_monad<Policy>::value_type>::value;
    };
    
    // Rebinds any input type to an output type preserving qualifiers
    template<class R, class T> struct rebind_cast_type { typedef R&& type; };
    template<class R, class T> struct rebind_cast_type<R, const T&> { typedef const R& type; };
    template<class R, class T> struct rebind_cast_type<R, T&> { typedef R& type; };
    template<class R, class T> struct rebind_cast_type<R, const T*> { typedef const R* type; };
    template<class R, class T> struct rebind_cast_type<R, T*> { typedef R* type; };
    template<class R, class T> typename rebind_cast_type<R, T&&>::type rebind_cast(T &&v) { return reinterpret_cast<typename rebind_cast_type<R, T&&>::type>(v); }
    // GCC <= 4.8 doesn't like this overload
    //template<class R, class T> typename rebind_cast_type<R, T&>::type rebind_cast(T &v) { return reinterpret_cast<typename rebind_cast_type<R, T&>::type>(v); }
    template<class R, class T> typename rebind_cast_type<R, T*>::type rebind_cast(T *&&v) { return reinterpret_cast<typename rebind_cast_type<R, T*>::type>(v); }
    template<class R, class T> typename rebind_cast_type<R, T*>::type rebind_cast(T *&v) { return reinterpret_cast<typename rebind_cast_type<R, T*>::type>(v); }

    /* Invokes the callable passed to next() folding any monad return type
    R is the type returned by the callable
    C is the callable
    Monad is the monad
    Policy is the implementation policy
    
    Call operator is always invoked with basic_monad.
    */
    // For when R is not a monad and not void
    template<class R, class C, template<class> class Monad, class Policy> struct do_simple_continuation
    {
      typedef typename std::decay<C>::type callable_type;
      // If the return type is an error_type or exception_type or void, reuse monad else rebind monad to R
      typedef typename std::conditional<std::is_same<R, typename Monad<Policy>::error_type>::value
          || std::is_same<R, typename Monad<Policy>::exception_type>::value
          || std::is_void<R>::value,
        Monad<Policy>,
        typename Monad<Policy>::template rebind<R>
      >::type output_type;
      typedef Monad<Policy> input_type;
      callable_type _c;
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR do_simple_continuation(U &&c) : _c(std::forward<U>(c)) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(input_type &&v) const
      {
        return traits::callable_argument_traits<callable_type, input_type>::is_rvalue
          ? output_type(_c(std::move(v)))
          : output_type(_c(input_type(v)));
      }
    };
    // For when R is void
    template<class C, template<class> class Monad, class Policy> struct do_simple_continuation<void, C, Monad, Policy>
    {
      typedef typename std::decay<C>::type callable_type;
      // If the return type is an error_type or exception_type or void, reuse monad else rebind monad to R
      typedef typename Monad<Policy>::template rebind<void> output_type;
      typedef Monad<Policy> input_type;
      callable_type _c;
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR do_simple_continuation(U &&c) : _c(std::forward<U>(c)) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(input_type &&v) const
      {
        return traits::callable_argument_traits<callable_type, input_type>::is_rvalue
          ? (_c(std::move(v)), output_type())
          : (_c(input_type(v)), output_type());
      }
    };
    // For when R is a monad
    template<class Policy1, class C, template<class> class Monad, class Policy2> struct do_simple_continuation<Monad<Policy1>, C, Monad, Policy2>
    {
      typedef typename std::decay<C>::type callable_type;
      typedef Monad<Policy1> output_type;
      typedef Monad<Policy2> input_type;
      callable_type _c;
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR do_simple_continuation(U &&c) : _c(std::forward<U>(c)) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(input_type &&v) const
      {
        return traits::callable_argument_traits<callable_type, input_type>::is_rvalue
          ? output_type(_c(std::move(v)))
          : output_type(_c(input_type(v)));
      }
    };
    template<class R, class C, class Policy> using do_next = do_simple_continuation<R, C, basic_monad, Policy>;

#ifdef BOOST_SPINLOCK_MONAD_ENABLE_OPERATORS
    template<bool is_monad_monad, class M> struct do_unwrap2;
    template<class M> using do_unwrap = do_unwrap2<is_monad_monad<M>::value, M>;
    template<bool is_monad_monad, class M> struct do_unwrap2
    {
      typedef M input_type;
      typedef input_type output_type;
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(const input_type &v) const { return v; }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(input_type &&v) const { return std::move(v); }
    };
    template<class M> struct do_unwrap2<true, M>
    {
      typedef M input_type;
      typedef typename input_type::value_type unwrapped_type;
      typedef typename do_unwrap<unwrapped_type>::output_type output_type;
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(const input_type &v) const
      {
        if(v.has_error())
          return do_unwrap<unwrapped_type>()(v.get_error());
        else if(v.has_exception())
          return do_unwrap<unwrapped_type>()(v.get_exception());
        else if(v.has_value())
          return do_unwrap<unwrapped_type>()(v.get());
        else
          return do_unwrap<unwrapped_type>()(unwrapped_type());
      }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(input_type &&v) const
      {
        if(v.has_error())
          return do_unwrap<unwrapped_type>()(std::move(v).get_error());
        else if(v.has_exception())
          return do_unwrap<unwrapped_type>()(std::move(v).get_exception());
        else if(v.has_value())
          return do_unwrap<unwrapped_type>()(std::move(v).get());
        else
          return do_unwrap<unwrapped_type>()(unwrapped_type());
      }
    };

    // Is the monad M's contents directly constructible from an R, not allowing a monad<monad<int>> being constructible from an int
    template<class M, class R, bool is_monad_monad=is_monad_monad<M>::value> struct is_monad_constructible : public std::is_constructible<typename M::value_type, R> {};
    template<class M, bool is_monad_monad> struct is_monad_constructible<M, typename M::error_type, is_monad_monad> : public std::true_type{};
    template<class M, bool is_monad_monad> struct is_monad_constructible<M, typename M::exception_type, is_monad_monad> : public std::true_type{};
    template<class M, bool is_monad_monad> struct is_monad_constructible<M, typename M::empty_type, is_monad_monad> : public std::true_type{};
    template<class M> struct is_monad_constructible<M, typename M::value_type::value_type, true> : public std::false_type{};
    template<class _F, class M> struct bind_map_parameter_validation
    {
      typedef typename std::decay<_F>::type F;
      // Figure out what the callable takes
      typedef traits::callable_argument_traits<F, typename M::value_type> f_value_traits;
      typedef traits::callable_argument_traits<F, typename M::error_type> f_error_traits;
      typedef traits::callable_argument_traits<F, typename M::exception_type> f_exception_traits;
      typedef traits::callable_argument_traits<F, typename M::empty_type> f_empty_traits;
      BOOST_STATIC_CONSTEXPR bool callable_takes_anything=f_value_traits::is_auto;
      BOOST_STATIC_CONSTEXPR bool callable_is_uncallable=!callable_takes_anything && !is_monad<typename M::value_type>::value && (f_value_traits::valid+f_error_traits::valid+f_exception_traits::valid+f_empty_traits::valid)==0;
      BOOST_STATIC_CONSTEXPR bool callable_is_ambiguous=!callable_takes_anything && !is_monad<typename M::value_type>::value && (f_value_traits::valid+f_error_traits::valid+f_exception_traits::valid+f_empty_traits::valid)>1;
      
      // Error out common mistakes in the callable parameter
      static_assert(!callable_is_uncallable,
        "Callable does not have an auto nor templated parameter and is not well formed for none of a value_type, an error_type, an exception_type nor an empty_type. You probably need to adjust the parameter being taken by your callable");
      static_assert(!callable_is_ambiguous,
        "Callable does not have an auto nor templated parameter, yet is well formed for more than one of value_type, error_type, exception_type and empty_type. As cannot disambiguate meaning, stopping");
      static_assert(!f_value_traits::valid || (callable_takes_anything || std::is_convertible<typename f_value_traits::type, typename M::value_type>::value),
        "A value_type consuming callable must have a parameter type which can be implicitly converted to from a value_type, or be an auto or templated parameter");
      static_assert(!f_error_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_error_traits::is_rvalue && std::is_same<typename f_error_traits::type, typename M::error_type>::value),
        "An error_type consuming callable must take an error_type by value");
      static_assert(!f_exception_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_exception_traits::is_rvalue && std::is_same<typename f_exception_traits::type, typename M::exception_type>::value),
        "An exception_type consuming callable must take an exception_type by value");
      static_assert(!f_empty_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_empty_traits::is_rvalue && std::is_same<typename f_empty_traits::type, typename M::empty_type>::value),
        "An empty_type consuming callable must take an empty_type by value");
      
      // Figure out what the callable returns
      using return_type = typename std::conditional<f_value_traits::valid,
        typename f_value_traits::return_type,
        typename std::conditional<f_error_traits::valid,
          typename f_error_traits::return_type,
          typename std::conditional<f_exception_traits::valid,
            typename f_exception_traits::return_type,
            typename std::conditional<f_empty_traits::valid,
              typename f_empty_traits::return_type,
              void
            >::type
          >::type
        >::type
      >::type;

      // Error out common mistakes in the return type
      static_assert(!f_error_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
        "An error_type consuming callable must return a type convertible to the monad type");
      static_assert(!f_exception_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
        "An exception_type consuming callable must return a type convertible to the monad type");
      static_assert(!f_empty_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
        "An empty_type consuming callable must return a type convertible to the monad type");
    };
    
    // Enable calling callable if is well formed and is either not auto or we're doing value_type
    template<class C, class U, class value_type, bool additional=true, class value_type2=void> struct enable_if_callable_valid
      : std::enable_if<additional && traits::callable_argument_traits<C, U>::valid
        && (!traits::callable_argument_traits<C, U>::is_auto || std::is_same<U, value_type>::value || std::is_same<U, value_type2>::value)>
    {};
    template<class C, class U, class value_type, bool additional> struct enable_if_callable_valid<C, U, value_type, additional, void>
      : std::enable_if<additional && traits::callable_argument_traits<C, U>::valid
      && (!traits::callable_argument_traits<C, U>::is_auto || std::is_same<U, value_type>::value)>
    {};
    /* Invokes the callable passed to next() and bind() and map() optionally folding any monad return type
    R is the type returned by the callable
    C is the callable
    M is the monad
    
    Call operator is invoked with any of value, error, exception or empty. If not well
    formed, passes through input.
    */
    template<bool fold_monadic_return, class R, class C, class M> struct do_continuation;
    // For when R is not a monad or map()
    template<bool fold_monadic_return, class R, class C, class Policy> struct do_continuation<fold_monadic_return, R, C, basic_monad<Policy>>
    {
      typedef typename std::decay<C>::type callable_type;
      // If the return type is an error_type or exception_type or void, reuse monad else rebind monad to R
      typedef typename std::conditional<std::is_same<R, typename basic_monad<Policy>::error_type>::value
          || std::is_same<R, typename basic_monad<Policy>::exception_type>::value
          || std::is_void<R>::value,
        basic_monad<Policy>,
        typename basic_monad<Policy>::template rebind<R> 
      >::type output_type;
      callable_type _c;
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(const callable_type &c) : _c(c) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &c) : _c(c) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &&c) : _c(std::move(c)) { }
      template<class U,
        typename=typename enable_if_callable_valid<callable_type, U, typename basic_monad<Policy>::value_type, !std::is_void<R>::value>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<4>) const
      {
        return traits::callable_argument_traits<callable_type, U>::is_rvalue
          ? output_type(_c(std::move(v)))
          : output_type(_c(U(v)));
      }
      template<class U,
        typename = typename enable_if_callable_valid<callable_type, U, typename basic_monad<Policy>::value_type, std::is_void<R>::value>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<3>) const
      {
        return traits::callable_argument_traits<callable_type, U>::is_rvalue
          ? (_c(std::move(v)), output_type())
          : (_c(U(v)), output_type());
      }
      template<class U, typename=typename std::enable_if<std::is_constructible<output_type, U>::value>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<2>) const { return output_type(std::forward<U>(v)); }
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&, traits::detail::rank<1>) const { return output_type(); }
    };
    // For when R is a monad
    template<class Policy1,
      class C,
      class Policy2> struct do_continuation<true,
        basic_monad<Policy1>,
        C,
        basic_monad<Policy2>
      >
    {
      typedef typename std::decay<C>::type callable_type;
      typedef basic_monad<Policy1> output_type;
      typedef basic_monad<Policy2> input_type;
      callable_type _c;
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(const callable_type &c) : _c(c) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &c) : _c(c) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &&c) : _c(std::move(c)) { }
      template<class U,
        typename = typename enable_if_callable_valid<callable_type, U, input_type, !std::is_void<typename output_type::value_type>::value, typename input_type::value_type>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<4>) const
      {
        return traits::callable_argument_traits<callable_type, U>::is_rvalue
          ? output_type(_c(std::move(v)))
          : output_type(_c(U(v)));
      }
      template<class U,
        typename = typename enable_if_callable_valid<callable_type, U, input_type, std::is_void<typename output_type::value_type>::value, typename input_type::value_type>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<3>) const
      {
        return traits::callable_argument_traits<callable_type, U>::is_rvalue
          ? (_c(std::move(v)), output_type())
          : (_c(U(v)), output_type());
      }
      template<class U, typename=typename std::enable_if<std::is_constructible<output_type, U>::value>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<2>) const { return output_type(std::forward<U>(v)); }
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&, traits::detail::rank<1>) const { return output_type(); }
    };

    template<class R, class C, class M> using do_bind = do_continuation<true,  R, C, M>;
    template<class R, class C, class M> using do_map  = do_continuation<false, R, C, M>;
#endif
  }

  //! \brief True if the type passed is a monad or a reference to a monad
  template<class M> struct is_monad : detail::is_monad<typename std::decay<M>::type> { };

  /*! \class basic_monad
  \brief Implements a configurable lightweight simple monadic value transport with the same semantics and API as a future
  \tparam implementation_policy An implementation policy type
  \ingroup monad
  
  */
  template<class implementation_policy> class basic_monad
  {
    // Allow my policy unfettered acces
    friend implementation_policy;
    // Allow my policy specialised with void unfettered access
    friend typename implementation_policy::template rebind_policy<void>;
    friend inline std::istream &operator>>(std::istream &s, basic_monad &v)
    {
      return s >> v._storage;
    }
    friend inline std::ostream &operator<<(std::ostream &s, const basic_monad &v)
    {
      return s << v._storage;
    }
  protected:
    typedef value_storage<implementation_policy> value_storage_type;
    value_storage_type _storage;
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(value_storage_type &&s) : _storage(std::move(s)) { }
  public:
    //! \brief This monad has a value_type
    BOOST_STATIC_CONSTEXPR bool has_value_type = value_storage_type::has_value_type;
    //! \brief This monad has an error_type
    BOOST_STATIC_CONSTEXPR bool has_error_type = value_storage_type::has_error_type;
    //! \brief This monad has an exception_type
    BOOST_STATIC_CONSTEXPR bool has_exception_type = value_storage_type::has_exception_type;
    //! \brief The final implementation type
    typedef typename value_storage_type::implementation_type implementation_type;
    //! \brief The type potentially held by the monad
    typedef typename value_storage_type::value_type value_type;
    //! \brief The error code potentially held by the monad
    typedef typename value_storage_type::error_type error_type;
    //! \brief The exception ptr potentially held by the monad
    typedef typename value_storage_type::exception_type exception_type;
    //! \brief Tag type for an empty monad
    struct empty_type { typedef implementation_type parent_type; };
    //! \brief Rebind this monad type into a different value_type
    template<typename U> using rebind = typename implementation_policy::template rebind<U>;

    //! \brief This monad will never throw exceptions during copy construction
    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_constructible = value_storage_type::is_nothrow_copy_constructible;
    //! \brief This monad will never throw exceptions during move construction
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_constructible = value_storage_type::is_nothrow_move_constructible;
    //! \brief This monad will never throw exceptions during copy assignment
    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_assignable = value_storage_type::is_nothrow_destructible && value_storage_type::is_nothrow_copy_constructible;
    //! \brief This monad will never throw exceptions during move assignment
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_assignable = value_storage_type::is_nothrow_destructible && value_storage_type::is_nothrow_move_constructible;
    //! \brief This monad will never throw exceptions during destruction
    BOOST_STATIC_CONSTEXPR bool is_nothrow_destructible = value_storage_type::is_nothrow_destructible;

    //! \brief Default constructor, initialises to empty
    basic_monad() = default;
    //! \brief Implicit constructor of an empty monad
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(empty_type) : basic_monad() { }
    //! \brief Implicit constructor from a value_type by copy
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value) : _storage(v) { }
    //! \brief Implicit constructor from a value_type by move
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value) : _storage(std::move(v)) { }
    /*! \brief Explicit constructor of a value_type allowing emplacement with no other means of construction. Only available
    if value_type which can't be a monad can be constructed from Args and if either there is more than one Arg or the Arg is not a value_type, an
    error_type, an exception_type nor an empty_type.
    */
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class... Args> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit basic_monad(Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Arg, Args...>::value);
#else
    template<class Arg, class... Args,
      typename = typename std::enable_if<has_value_type &&
        !is_monad<value_type>::value
        && std::is_constructible<value_type, Arg, Args...>::value
        && (sizeof...(Args)!=0 || 
          (!std::is_same<value_type, typename std::decay<Arg>::type>::value
          && !std::is_same<error_type, typename std::decay<Arg>::type>::value
          && !std::is_same<exception_type, typename std::decay<Arg>::type>::value
          && !std::is_same<empty_type, typename std::decay<Arg>::type>::value))
      >::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit basic_monad(Arg &&arg, Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Arg, Args...>::value) : _storage(typename value_storage_type::emplace_t(), std::forward<Arg>(arg), std::forward<Args>(args)...) { }
#endif
    //! \brief Implicit constructor from an initializer list
    template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(std::initializer_list<U> l) noexcept(std::is_nothrow_constructible<value_type, std::initializer_list<U>>::value) : _storage(typename value_storage_type::emplace_t(), std::move(l)) { }
    //! \brief Implicit constructor from a error_type by copy
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(const error_type &v) noexcept(std::is_nothrow_copy_constructible<error_type>::value) : _storage(v) { }
    //! \brief Implicit constructor from a error_type by move
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(error_type &&v) noexcept(std::is_nothrow_move_constructible<error_type>::value) : _storage(std::move(v)) { }
    //! \brief Implicit constructor from a exception_type by copy
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(const exception_type &v) noexcept(std::is_nothrow_copy_constructible<exception_type>::value) : _storage(v) { }
    //! \brief Implicit constructor from a exception_type by move
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(exception_type &&v) noexcept(std::is_nothrow_move_constructible<exception_type>::value) : _storage(std::move(v)) { }
    //! \brief Move constructor
    basic_monad(basic_monad &&) = default;
    //! \brief Move assignment. Firstly clears any existing state, so exception throws during move will leave the monad empty.
    basic_monad &operator=(basic_monad &&) = default;
    //! \brief Copy constructor
    basic_monad(const basic_monad &v) = default;
    //! \brief Copy assignment. Firstly clears any existing state, so exception throws during copy will leave the monad empty.
    basic_monad &operator=(const basic_monad &) = default;

    //! \brief Same as `true_(tribool(*this))`
    BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit operator bool() const noexcept { return has_value(); }
    //! \brief True if monad contains a value_type, unknown if monad is empty, else false if monad is errored/excepted.
    BOOST_SPINLOCK_FUTURE_CONSTEXPR operator tribool::tribool() const noexcept { return has_value() ? tribool::tribool::true_ : empty() ? tribool::tribool::unknown : tribool::tribool::false_; }
    //! \brief True if monad is not empty
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool is_ready() const noexcept
    {
      return _storage.type!=value_storage_type::storage_type::empty;
    }
    //! \brief True if monad is empty
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool empty() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::empty;
    }
    //! \brief True if monad contains a value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_value() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::value;
    }
    //! \brief True if monad contains an error_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_error() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::error;
    }
    /*! \brief True if monad contains an exception_type or error_type (any error_type is returned as an exception_ptr by get_exception()).
    This needs to be true for both for compatibility with Boost.Thread's future. If you really want to test only for has exception only,
    pass true as the argument.
    */
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_exception(bool only_exception=false) const noexcept
    {
      return _storage.type==value_storage_type::storage_type::exception || (!only_exception && _storage.type==value_storage_type::storage_type::error);
    }

    //! \brief Swaps one monad for another
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void swap(basic_monad &o) noexcept(is_nothrow_move_constructible)
    {
      _storage.swap(o._storage);
    }
    //! \brief Destructs any state stored, resetting to empty
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void clear() noexcept(is_nothrow_destructible)
    {
      _storage.clear();
    }

#define BOOST_SPINLOCK_MONAD_IMPL(name, qualifier) \
    BOOST_SPINLOCK_FUTURE_MSVC_HELP auto name() qualifier -> decltype(implementation_policy::_get_value(detail::rebind_cast<implementation_type>(*this))) \
    { \
      return implementation_policy::_get_value(detail::rebind_cast<implementation_type>(*this)); \
    }
    //! \brief If contains a value_type, returns a lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_MONAD_IMPL(get, &)
    //! \brief If contains a value_type, returns a lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_MONAD_IMPL(value, &)
    //! \brief If contains a value_type, returns a const lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_MONAD_IMPL(get, const &)
    //! \brief If contains a value_type, returns a const lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_MONAD_IMPL(value, const &)
#undef BOOST_SPINLOCK_MONAD_IMPL
#define BOOST_SPINLOCK_MONAD_IMPL(name, qualifier) \
    BOOST_SPINLOCK_FUTURE_MSVC_HELP auto name() qualifier -> decltype(implementation_policy::_get_value(std::move(detail::rebind_cast<implementation_type>(*this)))) \
    { \
      return implementation_policy::_get_value(std::move(detail::rebind_cast<implementation_type>(*this))); \
    }
    //! \brief If contains a value_type, returns a rvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_MONAD_IMPL(get, &&)
    //! \brief If contains a value_type, returns a rvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_MONAD_IMPL(value, &&)
#undef BOOST_SPINLOCK_MONAD_IMPL
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &get_or(value_type &v) & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &value_or(value_type &v) & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &get_or(const value_type &v) const & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &value_or(const value_type &v) const & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&get_or(value_type &&v) && noexcept
    {
      return has_value() ? std::move(_storage.value) : std::move(v);
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&value_or(value_type &&v) && noexcept
    {
      return has_value() ? std::move(_storage.value) : std::move(v);
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &get_and(value_type &v) & noexcept
    {
      return has_value() ? v: _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &value_and(value_type &v) & noexcept
    {
      return has_value() ? v : _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &get_and(const value_type &v) const & noexcept
    {
      return has_value() ? v: _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &value_and(const value_type &v) const & noexcept
    {
      return has_value() ? v: _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&get_and(value_type &&v) && noexcept
    {
      return has_value() ? std::move(v) : std::move(_storage.value);
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&value_and(value_type &&v) && noexcept
    {
      return has_value() ? std::move(v) : std::move(_storage.value);
    }
    //! \brief Disposes of any existing state, setting the monad to the value storage
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_state(value_storage_type &&v) { _storage.clear(); _storage.set_state(std::move(v)); }
    //! \brief Disposes of any existing state, setting the monad to a copy of the value_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(const value_type &v) { _storage.clear(); _storage.set_value(v); }
    //! \brief Disposes of any existing state, setting the monad to a move of the value_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(value_type &&v) { _storage.clear(); _storage.set_value(std::move(v)); }
    //! \brief Disposes of any existing state, setting the monad to a default value
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value() { _storage.clear(); _storage.set_value(value_type()); }
    //! \brief Disposes of any existing state, setting the monad to an emplaced construction
    template<class... Args> BOOST_SPINLOCK_FUTURE_MSVC_HELP void emplace(Args &&... args) { _storage.clear(); _storage.emplace_value(std::forward<Args>(args)...); }
    
    //! \brief If contains an error_type, returns that error_type. If contains an error, returns an error code of `monad_errc::exception_present`. Otherwise returns a null error_type. Can only throw the exception monad_error(no_state) if empty.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP auto get_error() const -> decltype(implementation_policy::_get_error(detail::rebind_cast<implementation_type>(*this)))
    {
      return implementation_policy::_get_error(detail::rebind_cast<implementation_type>(*this));
    }
    //! \brief If contains an error_type, returns that error_type else returns the error_type supplied
    BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error_or(error_type e) const noexcept { return has_error() ? _storage.error : std::move(e); }
    //! \brief If contains an error_type, return the supplied error_type else return the contained error_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error_and(error_type e) const noexcept { return has_error() ? std::move(e) : _storage.error; }
    //! \brief Disposes of any existing state, setting the monad to the error_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_error(error_type v) { _storage.clear(); _storage.set_error(std::move(v)); }
    
    //! \brief If contains an exception_type, returns that exception_type. If contains an error_type, returns system_error(error_type). If contains a value_type, returns a null exception_type. Can only throw the exception monad_error(no_state) if empty.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP auto get_exception() const -> decltype(implementation_policy::_get_exception(detail::rebind_cast<implementation_type>(*this)))
    {
      return implementation_policy::_get_exception(detail::rebind_cast<implementation_type>(*this));
    }
    //! \brief If contains an exception_type, returns that exception_type else returns the exception_type supplied
    BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception_or(exception_type e) const noexcept { return has_exception() ? _storage.exception : std::move(e); }
    //! \brief If contains an exception_type, return the supplied exception_type else return the contained exception_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception_and(exception_type e) const noexcept { return has_exception() ? std::move(e) : _storage.exception; }
    //! \brief Disposes of any existing state, setting the monad to the exception_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_exception(exception_type v) { _storage.clear(); _storage.set_exception(std::move(v)); }
    //! \brief Disposes of any existing state, setting the monad to make_exception_type(forward<E>(e))
    template<typename E> BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_exception(E &&e)
    {
      set_exception(make_exception_type(std::forward<E>(e)));
    }

    /*! \name Functional programming extensions (optional)
    \ingroup monad
    
    \note All code in this section can be enabled by defining BOOST_SPINLOCK_MONAD_ENABLE_OPERATORS.
    By default only next() is available. This prevents you writing code which impacts build times.
    
    Classic monadic programming consists of a sequence of nested functional operations:
    <dl>
      <dt>JOIN (single): monad<monad<T>>.get() -> monad<T></dt>
      <dt>JOIN (maximum): monad<monad<monad<monad<T>>>>.unwrap() -> monad<T></dt>
        <dd>Whatever is the first monad containing a non-monad is returned.</dd>
      <dt>MAP: monad<T>.map(R(T)) -> monad<R></dt>
        <dd>If callable maps T to R, map() maps a monad<T> to a monad<R> if monad<T>
        contains a T. If it contains an error or is empty, that is passed through.</dd>
      <dt>BIND: monad<T>.bind(monad<R>(T)) -> monad<R></dt>
      <dt>BIND: monad<T>.bind(R(T)) -> monad<R></dt>
        <dd>If callable maps T to monad<R> and if monad<T> contains a T, then bind() maps
        a monad<T> to a monad<R> else if callable maps T to R and if monad<T> contains a T,
        bind() maps a monad<T> to a monad<R>. In other words, returning a monad from the
        callable does not wrap it in another monad. If the originating monad did not
        contain a T, that is passed through.</dd>
    </dl>
    We also support monad<T>.next(R(monad<T>)) for semantic equivalence to futures where the
    callable is called with the originating monad. This
    acts like bind(), so if the callable returns a monad it is not wrapped in another
    monad. Unlike map() or bind(), next() always calls the callable no matter what the
    monad contains, so it is up to you to interrogate the monad. Note that the originating
    monad is passed by const lvalue ref unless the callable takes a rvalue ref to the monad.
    
    A quick use example:
    \snippet monad_example.cpp monad_bind_example
    \snippet unittests.cpp monad_match_example
    \snippet unittests.cpp monad_operators_example
    
    You will note in the code example that the type of the callable for bind() and map()
    determines what operation happens. Here are the rules:
    - If the monad contains a T and the callable takes a T or an `auto`, then:
      - If the callable takes a T or any reference to a T which isn't an rvalue reference,
      the T is passed by const lvalue reference (i.e. copy semantics).
      - If the callable takes a T by non-const rvalue reference, the T is passed by rvalue ref.
      This lets you move from the value held by the originating monad if so desired.
      - If the callable takes the originating monad or any reference to such which isn't a
      rvalue reference, then the originating monad is passed by const lvalue reference.
      - If the callable takes the originating monad by non-const rvalue reference, the
      originating monad is passed by rvalue reference.
    The ability to take the originating monad makes bind() identical to next() though much
    harder on build times. Note that these options let you rebind the type of the monad,
    so if your callable returns a different type from the originating monad then the resulting
    monad is based on that different return type.
    \warning The current implementation requires you to specify a non-dependent return
    type for all generic lambdas, else you'll get compile errors where the compiler tried
    to insert `error_type`, `exception_type` etc when it was trying to figure out if the
    return type is correct. A future implementation (once VS2015 has Expression SFINAE) may
    remove this restriction, until then just hard specify your return types if your lambdas
    take an `auto`, or use lambdas not taking `auto`.
    
    - If the monad contains an `error_type` and the callable takes an `error_type`, then
    call the callable, else pass through the monad. For this reason, any callable taking
    an `error_type` must always return the same monad type as the originating monad.
    - If the monad contains an `error_type` or an `exception_type` and the callable takes
    an `exception_type`, then call the callable, else pass through the monad. For this reason,
    any callable taking an `exception_type` must always return the same monad type as the
    originating monad.
    - If the monad is empty and the callable takes an `empty_type`, then call the callable,
    else pass through the monad. For this reason, any callable with an `empty_type` parameter must
    always return the same monad type as the originating monad.

    Note that for nested monads e.g. monad<monad<int>>, either or both of the inner or outer
    monads can be with value or with error or empty. You should have your binds and maps
    work appropriately.
    
    For maximum build performance, try to avoid bind() and map() as these use some hefty
    metaprogramming to deduce what kind of bind and map you're doing based on the callables
    passed. unwrap() is implemented using a recursively expanded structure which is probably
    okay for low unwrap depths. next() is probably the least weighty of the monadic operators
    as it's relatively dumb and the only metaprogramming is to determine whether to wrap
    the return type with a monad or not.
    
  ### Acknowledgements ###
    To T.C. on Stack Overflow for answering my question at https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference
    and without whose excellent answer the intelligent map() and bind() above could not work.
    */
    ///@{
    /*! \brief Return basic_monad(F(*this)) or F(*this) if the latter returns a monad.
    
    The callable F needs to consume a monad obviously enough, however if your callable takes a monad &&, you can move
    from the monad. Equally, you can avoid copies if your
    callable takes a reference argument. The callable F can be a generic lambda if desired.
    
    If your callable does not return a monad, a monad will be constructed to hold the type it does return
    inheriting the same error_code, exception_type etc of the originating monad. If your callable returns
    a monad, that monad can be of any template parameter configuration and it will be returned from next(). This
    allows a very easy way of converting between different configurations of monad cost free.
    */
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> monad<...> next(F &&f);
#else
    template<class _F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_next<typename traits::is_callable_is_well_formed<typename std::decay<_F>::type, basic_monad>::type, typename std::decay<_F>::type, implementation_policy>::output_type next(_F &&f)
    {
      typedef typename std::decay<_F>::type F;
      typedef traits::callable_argument_traits<F, basic_monad> f_traits;
      static_assert(f_traits::valid,
        "The callable passed to next() must take this monad type or a reference to it.");
      return detail::do_next<typename f_traits::return_type, F, implementation_policy>(std::forward<F>(f))(std::move(*this));
    }
#endif
    
#ifdef BOOST_SPINLOCK_MONAD_ENABLE_OPERATORS
    //! \brief If I am a monad<monad<...>>, return copy of most nested monad<...>, else return copy of *this
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    monad<...> unwrap() const &;
#else
    BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_unwrap<basic_monad>::output_type unwrap() const & { return detail::do_unwrap<basic_monad>()(*this); }
#endif
    //! \brief If I am a monad<monad<...>>, return move of most nested monad<...>, else return move of *this
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    monad<...> unwrap() &&;
#else
    BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_unwrap<basic_monad>::output_type unwrap() && { return detail::do_unwrap<basic_monad>()(std::move(*this)); }
#endif

    //! \brief If bool(*this), return basic_monad(F(get())).unwrap, else return basic_monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> monad<...> bind(F &&f);
#else
    template<class _F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_bind<typename detail::bind_map_parameter_validation<typename std::decay<_F>::type, basic_monad>::return_type, typename std::decay<_F>::type, basic_monad>::output_type bind(_F &&f)
    {
      typedef typename std::decay<_F>::type F;
      typedef detail::do_bind<typename detail::bind_map_parameter_validation<F, basic_monad>::return_type, F, basic_monad> impl;
      if(has_value())
        return impl(std::forward<F>(f))(std::move(_storage.value), traits::detail::rank<5>());
      else if(has_error())
        return impl(std::forward<F>(f))(std::move(_storage.error), traits::detail::rank<5>());
      else if(has_exception())
        return impl(std::forward<F>(f))(std::move(_storage.exception), traits::detail::rank<5>());
      else
        return impl(std::forward<F>(f))(empty_type(), traits::detail::rank<5>());
    }
#endif
    //! \brief If bool(*this), return basic_monad(F(get())).unwrap, else return basic_monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> monad<...> operator>>(F &&f);
#else
    template<class _F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_bind<typename detail::bind_map_parameter_validation<typename std::decay<_F>::type, basic_monad>::return_type, typename std::decay<_F>::type, basic_monad>::output_type operator>>(_F &&f)
    {
      return bind(std::forward<_F>(f));
    }
#endif
    
    //! \brief If bool(*this), return basic_monad(F(get())), else return basic_monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> monad<...> map(F &&f);
#else
    template<class _F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_map<typename detail::bind_map_parameter_validation<typename std::decay<_F>::type, basic_monad>::return_type, typename std::decay<_F>::type, basic_monad>::output_type map(_F &&f)
    {
      typedef typename std::decay<_F>::type F;
      typedef detail::do_map<typename detail::bind_map_parameter_validation<F, basic_monad>::return_type, F, basic_monad> impl;
      if(has_value())
        return impl(std::forward<F>(f))(std::move(_storage.value), traits::detail::rank<5>());
      else if(has_error())
        return impl(std::forward<F>(f))(std::move(_storage.error), traits::detail::rank<5>());
      else if(has_exception())
        return impl(std::forward<F>(f))(std::move(_storage.exception), traits::detail::rank<5>());
      else
        return impl(std::forward<F>(f))(empty_type(), traits::detail::rank<5>());
    }
#endif

    //! \brief Call callable F with the current contents of the monad. Whatever the callable returns for when it is called with value_type is the type of the resulting monad.
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> basic_monad(F(contents)).unwrap() match(F &&f);
#else
    template<class _F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_next<typename traits::is_callable_is_well_formed<typename std::decay<_F>::type, value_type>::type, typename traits::is_callable_is_well_formed<typename std::decay<_F>::type, value_type>::type(basic_monad &&), implementation_policy>::output_type match(_F &&f)
    {
      typedef typename std::decay<_F>::type F;
      typedef traits::callable_argument_traits<F, value_type> f_traits_value;
      static_assert(f_traits_value::valid, "Callable is not well formed when called with value_type");
      auto invoke_f=[
#ifdef __cpp_init_captures
        f=std::forward<F>(f)
#else
        f
#endif
      ](basic_monad &&m)
      {
        return f_traits_value::is_rvalue ?
          (
            m.has_value() ? f(std::move(m).get()) :
            m.has_error() ? f(std::move(m).get_error()) :
            m.has_exception() ? f(std::move(m).get_exception()) :
            f(empty_type())
          ) : (
            m.has_value() ? f(m.get()) :
            m.has_error() ? f(m.get_error()) :
            m.has_exception() ? f(m.get_exception()) :
            f(empty_type())
          );
      };
      return next(std::move(invoke_f));
    }

    //! \brief If contains a value_type, invoke the call operator on that type. Return type must be default constructible.
    template<class... Args, typename = typename std::result_of<value_type(Args...)>::type> BOOST_SPINLOCK_FUTURE_MSVC_HELP auto operator()(Args &&... args) const -> decltype(this->get()(std::forward<Args>(args)...))
    {
      typedef decltype(get()(std::forward<Args>(args)...)) rettype;
      return has_value() ? get()(std::forward<Args>(args)...) : rettype();
    }

    //! \brief If contains a value_type, return that value type, else return the supplied type
    template<class U, typename=typename std::enable_if<std::is_constructible<basic_monad, U>::value>::type> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR basic_monad operator|(U &&v) &
    {
      return has_value() ? *this : basic_monad(std::forward<U>(v));
    }
    //! \brief If contains a value_type, return that value type, else return the supplied type
    template<class U, typename=typename std::enable_if<std::is_constructible<basic_monad, U>::value>::type> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR basic_monad operator|(U &&v) const &
    {
      return has_value() ? *this : basic_monad(std::forward<U>(v));
    }
    //! \brief If contains a value_type, return that value type, else return the supplied type
    template<class U, typename=typename std::enable_if<std::is_constructible<basic_monad, U>::value>::type> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR basic_monad operator|(U &&v) &&
    {
      return has_value() ? std::move(*this) : basic_monad(std::forward<U>(v));
    }
    //! \brief If contains a value_type, return the supplied type else the value_type
    template<class U, typename=typename std::enable_if<std::is_constructible<basic_monad, U>::value>::type> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR basic_monad operator&(U &&v) &
    {
      return has_value() ? basic_monad(std::forward<U>(v)) : *this;
    }
    //! \brief If contains a value_type, return the supplied type else the value_type
    template<class U, typename=typename std::enable_if<std::is_constructible<basic_monad, U>::value>::type> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR basic_monad operator&(U &&v) const &
    {
      return has_value() ? basic_monad(std::forward<U>(v)) : *this;
    }
    //! \brief If contains a value_type, return the supplied type else the value_type
    template<class U, typename=typename std::enable_if<std::is_constructible<basic_monad, U>::value>::type> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR basic_monad operator&(U &&v) &&
    {
      return has_value() ? basic_monad(std::forward<U>(v)) : std::move(*this);
    }
    
    
#endif
  ///@}
#endif
  };
  
  namespace detail
  {
    //! [monad_policy]
    //! \brief An implementation policy for basic_monad \ingroup monad
    template<typename R> struct monad_policy;
    template<> struct monad_policy<void>
    {
      // The final resulting implementation type
      typedef basic_monad<monad_policy> implementation_type;
      // The value type to use. Can be void to disable.
      typedef void value_type;
      // The error code type to use. Can be void to disable.
      typedef std::error_code error_type;
      // The exception pointer type to use. Can be void to disable.
      typedef std::exception_ptr exception_type;
      // Used by basic_future only, otherwise leave as void.
      typedef void pointer_type;
      // The type which basic_monad::rebind<U> should return
      template<typename U> using rebind = basic_monad<monad_policy<U>>;
      // The type which rebinding myself produces
      template<typename U> using rebind_policy = monad_policy<U>;
      // Must handle error situation ec. Can return false to cancel the calling operation.
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP bool _throw_error(monad_errc ec)
      {
        throw monad_error(ec);
      }
    protected:
      // Common preamble to the below
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _pre_get_value(U &&self)
      {
        if(!self.is_ready())
          _throw_error(monad_errc::no_state);
        if(self.has_error() || self.has_exception())
        {
          if(self.has_error())
            throw std::system_error(self._storage.error);
          if(self.has_exception())
            std::rethrow_exception(self._storage.exception);
        }      
      }
    public:
      // As we are void, we return only void
      // Called by get() &
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(implementation_type &self) { _pre_get_value(self); }
      // Called by get() const &
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(const implementation_type &self) {_pre_get_value(self); }
      // Called by get() &&
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(implementation_type &&self) {_pre_get_value(self); }
      // Called by get_error() const
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type _get_error(const U &self)
      {
        if(!self.is_ready())
        {
          if(!_throw_error(monad_errc::no_state))
            return error_type();
        }
        if(self.has_error())
          return self._storage.error;
        if(self.has_exception())
          return error_type((int) monad_errc::exception_present, monad_category());
        return error_type();
      }
      // Called by get_exception() const
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type _get_exception(const U &self)
      {
        if(!self.is_ready())
        {
          if(!_throw_error(monad_errc::no_state))
            return exception_type();
        }
        if(!self.has_error() && !self.has_exception())
          return exception_type();
        if(self.has_error())
          return std::make_exception_ptr(std::system_error(self._storage.error));
        if(self.has_exception())
          return self._storage.exception;
        return exception_type();
      }
    };
    template<typename R> struct monad_policy : public monad_policy<void>
    {
      // The final resulting implementation type
      typedef basic_monad<monad_policy> implementation_type;
      // The value type to use. Can be void to disable.
      typedef R value_type;
    protected:
      typedef monad_policy<void> impl;
    public:
      // Called by get() &
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &_get_value(implementation_type &self)
      {
        impl::_pre_get_value(self);
        return self._storage.value;
      }
      // Called by get() const &
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &_get_value(const implementation_type &self)
      {
        impl::_pre_get_value(self);
        return self._storage.value;
      }
      // Called by get() &&
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&_get_value(implementation_type &&self)
      {
        impl::_pre_get_value(self);
        return std::move(self._storage.value);
      }
    };
    //! [monad_policy]
    
    //! \brief An implementation policy for basic_monad \ingroup monad
    template<typename R> struct result_policy;
    template<> struct result_policy<void>
    {
      typedef basic_monad<result_policy> implementation_type;
      typedef void value_type;
      typedef std::error_code error_type;
      typedef void exception_type;
      typedef void pointer_type;
      template<typename U> using rebind = basic_monad<result_policy<U>>;
      template<typename U> using rebind_policy = result_policy<U>;
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP bool _throw_error(monad_errc ec)
      {
        throw monad_error(ec);
      }
    protected:
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _pre_get_value(U &&self)
      {
        if(!self.is_ready())
          _throw_error(monad_errc::no_state);
        if(self.has_error() || self.has_exception())
        {
          if(self.has_error())
            throw std::system_error(self._storage.error);
        }      
      }
    public:
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(implementation_type &self) { _pre_get_value(self); }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(const implementation_type &self) {_pre_get_value(self); }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(implementation_type &&self) {_pre_get_value(self); }
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type _get_error(const U &self)
      {
        if(!self.is_ready())
        {
          if(!_throw_error(monad_errc::no_state))
            return error_type();
        }
        if(!self.has_error())
          return error_type();
        return self._storage.error;
      }
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type _get_exception(const U &self);
    };
    template<typename R> struct result_policy : public result_policy<void>
    {
      typedef basic_monad<result_policy> implementation_type;
      typedef R value_type;
    protected:
      typedef result_policy<void> impl;
    public:
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &_get_value(implementation_type &self)
      {
        impl::_pre_get_value(self);
        return self._storage.value;
      }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &_get_value(const implementation_type &self)
      {
        impl::_pre_get_value(self);
        return self._storage.value;
      }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&_get_value(implementation_type &&self)
      {
        impl::_pre_get_value(self);
        return std::move(self._storage.value);
      }
    };

    //! \brief An implementation policy for basic_monad \ingroup monad
    template<typename R> struct option_policy;
    template<> struct option_policy<void>
    {
      typedef basic_monad<option_policy> implementation_type;
      typedef void value_type;
      typedef void error_type;
      typedef void exception_type;
      typedef void pointer_type;
      template<typename U> using rebind = basic_monad<option_policy<U>>;
      template<typename U> using rebind_policy = option_policy<U>;
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP bool _throw_error(monad_errc ec)
      {
        throw monad_error(ec);
      }
    protected:
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _pre_get_value(U &&self)
      {
        if(!self.is_ready())
          _throw_error(monad_errc::no_state);
      }
    public:
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(implementation_type &self) { _pre_get_value(self); }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(const implementation_type &self) {_pre_get_value(self); }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value(implementation_type &&self) {_pre_get_value(self); }
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type _get_error(const U &self);
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type _get_exception(const U &self);
    };
    template<typename R> struct option_policy : public option_policy<void>
    {
      typedef basic_monad<option_policy> implementation_type;
      typedef R value_type;
    protected:
      typedef option_policy<void> impl;
    public:
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &_get_value(implementation_type &self)
      {
        impl::_pre_get_value(self);
        return self._storage.value;
      }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &_get_value(const implementation_type &self)
      {
        impl::_pre_get_value(self);
        return self._storage.value;
      }
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&_get_value(implementation_type &&self)
      {
        impl::_pre_get_value(self);
        return std::move(self._storage.value);
      }
    };

  }

  /*! \brief `monad<R>` can hold a fixed variant list of empty, a type `R`, a lightweight `std::error_code` or a
  heavier `std::exception_ptr` at a space cost of `max(24, sizeof(R)+8)`. This corresponds to `tribool::unknown`,
  `tribool::true_`, `tribool::false_` and `tribool::false_` respectively. \ingroup monad
  */
  template<typename R> using monad = basic_monad<detail::monad_policy<R>>;
  /*! \brief `result<R>` can hold a fixed variant list of empty, a type `R` or a lightweight `std::error_code` at a
  space cost of `max(24, sizeof(R)+8)`. This corresponds to `tribool::unknown`, `tribool::true_` and
  `tribool::false_` respectively. This specialisation looks deliberately like Rust's `Result<T>`. \ingroup monad
  */
  template<typename R> using result = basic_monad<detail::result_policy<R>>;
  /*! \brief `option<R>` can hold a fixed variant list of empty or a type `R` at a space cost of `sizeof(value_storage<R>)`
  which is usually `sizeof(R)+8`, but may be smaller if `value_storage<R>` is specialised. This
  corresponds to `tribool::unknown` and `tribool::true_` respectively. This specialisation looks deliberately
  like Rust's `Option<T>`. \ingroup monad
  */
  template<typename R> using option = basic_monad<detail::option_policy<R>>;

  //! \brief Makes a monad from the type passed \ingroup monad
  template<class T> monad<T> make_monad(T &&v) { return monad<T>(std::forward<T>(v)); }
  //! \brief Makes an errored monad of type T \ingroup monad
  template<class T> monad<T> make_monad(std::error_code v) { return monad<T>(std::move(v)); }
  //! \brief Makes an excepted monad of type T \ingroup monad
  template<class T> monad<T> make_monad(std::exception_ptr v) { return monad<T>(std::move(v)); }
  //! \brief Makes an empty monad of type T \ingroup monad
  template<class T> monad<T> make_monad() { return monad<T>(); }
}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
  //! \brief Specialise swap for basic_monad \ingroup monad
  template<class Impl> inline void swap(BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::basic_monad<Impl> &a, BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::basic_monad<Impl> &b)
  {
    a.swap(b);
  }
  //! \brief Deserialise a value_storage value_type (only value_type) \ingroup monad
  template<class Impl> inline istream &operator>>(istream &s, BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::value_storage<Impl> &v)
  {
    using namespace BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures;
    switch (v.type)
    {
    case value_storage<Impl>::storage_type::value:
      return s >> v.value;
    default:
      throw ios_base::failure("Set the type of lightweight_futures::value_storage to a value_type before deserialising into it");
    }
    return s;
  }
  //! \brief Serialise a value_storage. Mostly useful for debug printing. \ingroup monad
  template<class Impl> inline ostream &operator<<(ostream &s, const BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::value_storage<Impl> &v)
  {
    using namespace BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures;
    switch (v.type)
    {
    case value_storage<Impl>::storage_type::empty:
      return s << "(empty)";
    case value_storage<Impl>::storage_type::value:
      return s << v.value;
    case value_storage<Impl>::storage_type::error:
      return s << "(" << v.error.category().name() << " std::error_code " << v.error.value() << ": " << v.error.message() << ")";
    case value_storage<Impl>::storage_type::exception:
      try
      {
        rethrow_exception(v.exception);
      }
      catch(const system_error &e)
      {
        return s << "(std::system_error code " << e.code() << ": " << e.what() << ")";
      }
      /*catch(const future_error &e)
      {
        return s << "(std::future_error code " << e.code() << ": " << e.what() << ")";
      }*/
      catch(const exception &e)
      {
        return s << "(std::exception: " << e.what() << ")";
      }
      catch(...)
      {
        return s << "(unknown exception)";
      }
    default:
      return s << "(unknown)";
    }
    return s;
  }
}

#endif
