/* monad.hpp
The world's most simple C++ monad
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: June 2015


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_SPINLOCK_MONAD_HPP
#define BOOST_SPINLOCK_MONAD_HPP

#include "tribool.hpp"

// For some odd reason, VS2015 really hates to do much inlining unless forced
#ifdef _MSC_VER
# define BOOST_SPINLOCK_FUTURE_CONSTEXPR BOOST_FORCEINLINE
# define BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR BOOST_FORCEINLINE
# define BOOST_SPINLOCK_FUTURE_MSVC_HELP BOOST_FORCEINLINE
#else
# define BOOST_SPINLOCK_FUTURE_CONSTEXPR BOOST_CONSTEXPR
# define BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR BOOST_CXX14_CONSTEXPR
# define BOOST_SPINLOCK_FUTURE_MSVC_HELP 
#endif

/*! \file monad.hpp
\brief Provides a lightweight simple monadic value transport

\headerfile include/boost/spinlock/monad.hpp ""
*/

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN

namespace traits
{
  namespace detail
  {
    // Gets the return type of F(A), returning a not_well_formed type if not well formed
    template<class F, class A> struct get_return_type
    {
      struct not_well_formed {};
      template<class _F, class _A> static not_well_formed test(...);
      template<class _F, class _A> static auto test(_F &&f) -> decltype(f(std::declval<_A>()));
      using type = decltype(test<F, A>(std::declval<F>()));
    };

    // Without Expression SFINAE (VS2015), I actually don't know of a better way :(
    template<class T, class Arg> class has_call_operator2
    {
      struct Fallback { int operator()(Arg); };
      struct Derived : T, Fallback { };

      template<typename U, U> struct Check;

      typedef char ArrayOfOne[1], ArrayOfTwo[2];

      template<typename U> static ArrayOfOne & func(Check<int Fallback::*, &U::operator()> *);
      template<typename U> static ArrayOfTwo & func(...);

    public:
      BOOST_STATIC_CONSTEXPR bool value = sizeof(func<Derived>(0)) == 2;
    };
    template <bool enable, typename F, typename Arg> struct has_call_operator : public std::false_type {};
    template <typename F, typename Arg> struct has_call_operator<true, F, Arg> : public has_call_operator2<F, typename get_return_type<F, Arg>::type(Arg)>{};

    template<bool _is_move, bool _is_auto, typename T=void> struct arg_form
    {
      BOOST_STATIC_CONSTEXPR bool is_rvalue = _is_move;
      BOOST_STATIC_CONSTEXPR bool is_auto = _is_auto;
      using non_auto_type = T;
    };

    template<int R> struct rank : rank<R - 1> { static_assert(R > 0, ""); };
    template<> struct rank<0> {};

    template<class F, class A> struct call_operator_argument_form
    {
      using return_type = typename get_return_type<F, A>::type;
      using arg_type = typename std::decay<A>::type;

      static arg_form<false, true> test(return_type(F::*)(const arg_type&)      , rank<1>);
      static arg_form<false, true> test(return_type(F::*)(arg_type&)            , rank<2>);
      static arg_form<true , true> test(return_type(F::*)(arg_type&&)           , rank<3>);
      static arg_form<false, true> test(return_type(F::*)(arg_type)             , rank<4>);
      static arg_form<false, true> test(return_type(F::*)(const arg_type&) const, rank<5>);
      static arg_form<false, true> test(return_type(F::*)(arg_type&)       const, rank<6>);
      static arg_form<true , true> test(return_type(F::*)(arg_type&&)      const, rank<7>);
      static arg_form<false, true> test(return_type(F::*)(arg_type)        const, rank<8>);

      template<class T> static arg_form<false, false, T> test(return_type(F::*)(T)             , rank<9>);
      template<class T> static arg_form<false, false, T> test(return_type(F::*)(T&)            , rank<10>);
      template<class T> static arg_form<true , false, T> test(return_type(F::*)(T&&)           , rank<11>);
      template<class T> static arg_form<false, false, T> test(return_type(F::*)(T)        const, rank<12>);
      template<class T> static arg_form<false, false, T> test(return_type(F::*)(T&)       const, rank<13>);
      template<class T> static arg_form<true , false, T> test(return_type(F::*)(T&&)      const, rank<14>);

      using result = decltype(test(&F::operator(), rank<15>()));

      BOOST_STATIC_CONSTEXPR bool is_rvalue = result::is_rvalue;
      BOOST_STATIC_CONSTEXPR bool is_auto = result::is_auto;
      using type = typename result::non_auto_type;
    };

    template<class F, class A> struct function_argument_form
    {
      using return_type = typename get_return_type<F, A>::type;
      using arg_type = typename std::decay<A>::type;

      static arg_form<false, true> test(return_type(*)(const arg_type&)      , rank<1>);
      static arg_form<false, true> test(return_type(*)(arg_type&)            , rank<2>);
      static arg_form<true , true> test(return_type(*)(arg_type&&)           , rank<3>);
      static arg_form<false, true> test(return_type(*)(arg_type)             , rank<4>);

      template<class T> static arg_form<false, false, T> test(return_type(*)(T)             , rank<5>);
      template<class T> static arg_form<false, false, T> test(return_type(*)(T&)            , rank<6>);
      template<class T> static arg_form<true , false, T> test(return_type(*)(T&&)           , rank<7>);

      using result = decltype(test(F(), rank<10>()));

      BOOST_STATIC_CONSTEXPR bool is_rvalue = result::is_rvalue;
      BOOST_STATIC_CONSTEXPR bool is_auto = result::is_auto;
      using type = typename result::non_auto_type;
    };

  }

  //! \brief Is the callable F called with Arg well formed?
  template<class F, class A> struct is_callable_is_well_formed
  {
    using return_type = detail::get_return_type<F, A>;
    //! \brief The type returned by the callable F when called with Arg
    using type = typename return_type::type;
    //! \brief Whether the call with Arg is well formed
    BOOST_STATIC_CONSTEXPR bool value = !std::is_same<type, typename return_type::not_well_formed>::value;
  };

  //! \brief Is F a class type and does it have a call operator callable with Arg?
  template<typename F, typename Arg> struct has_call_operator
    : public detail::has_call_operator<std::is_class<F>::value, F, Arg>
  { };

  namespace detail
  {
    template<bool enable, class F, class A> struct callable_argument_traits
    {
      //! \brief Is the callable F called with Arg well formed?
      BOOST_STATIC_CONSTEXPR bool valid = false;
      //! \brief Is the arg a rvalue ref?
      BOOST_STATIC_CONSTEXPR bool is_rvalue = false;
      //! \brief Is the arg a templated arg?
      BOOST_STATIC_CONSTEXPR bool is_auto = false;
      //! \brief If the arg is not a templated arg, it is this type
      using type = void;
    };
    template<class F, class A> struct callable_argument_traits<true, F, A>
      : public std::conditional<!std::is_function<F>::value && has_call_operator<std::is_class<F>::value, F, A>::value,
        detail::call_operator_argument_form<F, A>,
        detail::function_argument_form<F, A>
      >::type
    {
      BOOST_STATIC_CONSTEXPR bool valid = true;
  };
  }

  /*! \brief If callable F were to be called with A, tell me about the call.
  */
  template<class F, class A> struct callable_argument_traits
    : public detail::callable_argument_traits<is_callable_is_well_formed<F, A>::value, F, A>
  {
    //! The type returned by the callable when called with A
    using return_type=typename is_callable_is_well_formed<F, A>::type;
  };

}

namespace lightweight_futures
{

  //! \brief Enumeration of the ways in which a monad operation may fail
  enum class monad_errc {
    already_set = 1,  //!< Attempt to store a value into the monad twice
    no_state = 2      //!< Attempt to use without a state
  };

  namespace detail
  {
    class monad_category : public std::error_category
    {
    public:
      virtual const char *name() const noexcept { return "monad"; }
      virtual std::string message(int c) const
      {
        switch(c)
        {
          case 1: return "already_set";
          case 2: return "no_state";
          default: return "unknown";
        }
      }
    };
  }

  /*! \brief Returns a reference to a monad error category. Note the address
  of one of these may not be constant throughout the process as per the ISO spec.
  */
  inline const detail::monad_category &monad_category()
  {
    static detail::monad_category c;
    return c;
  }

  //! \brief A monad exception object
  class BOOST_SYMBOL_VISIBLE monad_error : public std::logic_error
  {
    std::error_code _ec;
  public:
    monad_error(std::error_code ec) : std::logic_error(ec.message()), _ec(std::move(ec)) { }
    const std::error_code &code() const noexcept { return _ec; }
  };

  inline std::error_code make_error_code(monad_errc e)
  {
    return std::error_code(static_cast<int>(e), monad_category());
  }

  inline std::error_condition make_error_condition(monad_errc e)
  {
    return std::error_condition(static_cast<int>(e), monad_category());
  }

}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
  template<> struct is_error_code_enum<BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad_errc> : std::true_type {};
  template<> struct is_error_condition_enum<BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad_errc> : std::true_type {};
}

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN
namespace lightweight_futures {

  /*! \class value_storage
  \tparam implementation_policy A policy type providing a `value_type`, an `error_type`, an `exception_type`, an
  `implementation_type` and a function called `bool _throw_error(monad_errc)`.
  \brief A fixed lightweight variant store for monad.
  
  This fixed variant list of empty, a type `R`, a lightweight `error_type` or a
  heavier `exception_type` typically has a space cost of `max(20, sizeof(R)+4)`.
  
  \todo Small space specialisations for value_storage<void> and value_storage<bool> and value_storage<tribool>
  */
  template<class implementation_policy> class value_storage
  {
    // Define stand in types for when these are void. As they are private, they
    // are disabled for SFINAE and any attempt to use them yields a useful error message.
    struct no_value_type {};
    struct no_error_type {};
    struct no_exception_type {};
    struct no_pointer_type { no_pointer_type(std::nullptr_t) { } };
    template<class U, class V> using devoid = typename std::conditional<!std::is_void<U>::value, U, V>::type;
  public:
    BOOST_STATIC_CONSTEXPR bool has_value_type = !std::is_void<typename implementation_policy::value_type>::value;
    BOOST_STATIC_CONSTEXPR bool has_error_type = !std::is_void<typename implementation_policy::error_type>::value;
    BOOST_STATIC_CONSTEXPR bool has_exception_type = !std::is_void<typename implementation_policy::exception_type>::value;
    BOOST_STATIC_CONSTEXPR bool has_pointer_type = !std::is_void<typename implementation_policy::pointer_type>::value;
    typedef typename implementation_policy::implementation_type implementation_type;
    typedef devoid<typename implementation_policy::value_type, no_value_type> value_type;
    typedef devoid<typename implementation_policy::error_type, no_error_type> error_type;
    typedef devoid<typename implementation_policy::exception_type, no_exception_type> exception_type;
    typedef devoid<typename implementation_policy::pointer_type, no_pointer_type> pointer_type;
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4624)
#endif
    union
    {
      value_type value;
      error_type error;              // Often 16 bytes surprisingly
      exception_type exception;      // Typically 8 bytes
      pointer_type pointer_;         // Typically 8 bytes
    };
#ifdef _MSC_VER
#pragma warning(pop)
#endif
    enum class storage_type : unsigned char
    {
      empty,
      value,
      error,
      exception,
      pointer
    } type;

    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_constructible = std::is_nothrow_copy_constructible<value_type>::value && std::is_nothrow_copy_constructible<exception_type>::value && std::is_nothrow_copy_constructible<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_constructible = std::is_nothrow_move_constructible<value_type>::value && std::is_nothrow_move_constructible<exception_type>::value && std::is_nothrow_move_constructible<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_assignable = std::is_nothrow_copy_assignable<value_type>::value && std::is_nothrow_copy_assignable<exception_type>::value && std::is_nothrow_copy_assignable<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_assignable = std::is_nothrow_move_assignable<value_type>::value && std::is_nothrow_move_assignable<exception_type>::value && std::is_nothrow_move_assignable<error_type>::value;
    BOOST_STATIC_CONSTEXPR bool is_nothrow_destructible = std::is_nothrow_destructible<value_type>::value && std::is_nothrow_destructible<exception_type>::value && std::is_nothrow_destructible<error_type>::value;

#if !defined(__GNUC__) || defined(__clang__)
    /* If enabled GCC pukes during unwrap() with:
        /usr/include/c++/5/type_traits:2204:7: error: static assertion failed: declval() must not be used!
          static_assert(__declval_protector<_Tp>::__stop,
        Apparently it's a known problem in constexpr compilation, and has been for some years now.
    */
    BOOST_SPINLOCK_FUTURE_CONSTEXPR
#endif
      value_storage() noexcept : type(storage_type::empty) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value) : value(v), type(storage_type::value) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const error_type &v) noexcept(std::is_nothrow_copy_constructible<error_type>::value) : error(v), type(storage_type::error) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const exception_type &v) noexcept(std::is_nothrow_copy_constructible<exception_type>::value) : exception(v), type(storage_type::exception) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value) : value(std::move(v)), type(storage_type::value) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(error_type &&v) noexcept(std::is_nothrow_move_constructible<error_type>::value) : error(std::move(v)), type(storage_type::error) { }
    BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(exception_type &&v) noexcept(std::is_nothrow_move_constructible<exception_type>::value) : exception(std::move(v)), type(storage_type::exception) { }
    struct emplace_t {};
    template<class... Args> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit value_storage(emplace_t, Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Args...>::value) : value(std::forward<Args>(args)...), type(storage_type::value) { }

    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage(const value_storage &o) noexcept(is_nothrow_copy_constructible) : type(storage_type::empty)
    {
      switch (o.type)
      {
      case storage_type::empty:
        break;
      case storage_type::value:
        new (&value) value_type(o.value);
        break;
      case storage_type::error:
        new (&error) error_type(o.error);
        break;
      case storage_type::exception:
        new (&exception) exception_type(o.exception);
        break;
      case storage_type::pointer:
        abort();  // Pointer storage only ever has move semantics
        break;
      }
      type = o.type;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage(value_storage &&o) noexcept(is_nothrow_move_constructible) : type(storage_type::empty)
    {
      switch (o.type)
      {
      case storage_type::empty:
        break;
      case storage_type::value:
        new (&value) value_type(std::move(o.value));
        break;
      case storage_type::error:
        new (&error) error_type(std::move(o.error));
        break;
      case storage_type::exception:
        new (&exception) exception_type(std::move(o.exception));
        break;
      case storage_type::pointer:
        pointer_ = o.pointer_;
        o.pointer_ = nullptr;
        break;
      }
      type = o.type;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage &operator=(const value_storage &o) noexcept(is_nothrow_destructible && is_nothrow_copy_constructible)
    {
      clear();
      new (this) value_storage(o);
      return *this;
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage &operator=(value_storage &&o) noexcept(is_nothrow_destructible && is_nothrow_move_constructible)
    {
      clear();
      new (this) value_storage(std::move(o));
      return *this;
    }
    BOOST_SPINLOCK_FUTURE_MSVC_HELP ~value_storage() noexcept(is_nothrow_destructible) { clear(); }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void swap(value_storage &o) noexcept(is_nothrow_move_constructible)
    {
      if (type == o.type)
      {
        switch (type)
        {
        case storage_type::empty:
          break;
        case storage_type::value:
          std::swap(value, o.value);
          break;
        case storage_type::error:
          std::swap(error, o.error);
          break;
        case storage_type::exception:
          std::swap(exception, o.exception);
          break;
        case storage_type::pointer:
          std::swap(pointer_, o.pointer_);
          break;
        }
      }
      else
      {
        value_storage temp(std::move(o));
        o = std::move(*this);
        *this = std::move(temp);
      }
    }
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void clear() noexcept(is_nothrow_destructible)
    {
      switch (type)
      {
      case storage_type::empty:
        break;
      case storage_type::value:
        value.~value_type();
        type = storage_type::empty;
        break;
      case storage_type::error:
        error.~error_type();
        type = storage_type::empty;
        break;
      case storage_type::exception:
        exception.~exception_type();
        type = storage_type::empty;
        break;
      case storage_type::pointer:
        pointer_ = nullptr;
        type = storage_type::empty;
        break;
      }
    }
    template<class U> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_value(U &&v)
    {
      if (type != storage_type::empty)
      {
        if(!implementation_policy::_throw_error(monad_errc::already_set)) return;
      }
      new (&value) value_type(std::forward<U>(v));
      type = storage_type::value;
    }
    template<class... Args> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void emplace_value(Args &&... v)
    {
      if (type != storage_type::empty)
      {
        if(!implementation_policy::_throw_error(monad_errc::already_set)) return;
      }
      new (&value) value_type(std::forward<Args>(v)...);
      type = storage_type::value;
    }
    void set_exception(exception_type e)
    {
      if (type != storage_type::empty)
      {
        if(!implementation_policy::_throw_error(monad_errc::already_set)) return;
      }
      new (&exception) exception_type(std::move(e));
      type = storage_type::exception;
    }
    // Note to self: this can't be BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR
    void set_error(error_type e)
    {
      if (type != storage_type::empty)
      {
        if(!implementation_policy::_throw_error(monad_errc::already_set)) return;
      }
      new (&error) error_type(std::move(e));
      type = storage_type::error;
    }
    // Called by future to take ownership of storage from promise
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_pointer(pointer_type f) noexcept(is_nothrow_destructible)
    {
      // Always overwrites existing storage
      clear();
      pointer_ = f;
      type = storage_type::pointer;
    }
  };

  template<class Impl> class basic_monad;

  namespace detail
  {
    template<class M> struct is_monad : std::false_type {};
    template<class Impl> struct is_monad<basic_monad<Impl>> : std::true_type{};
    
    // Does the monad contain a monad?
    template<class> struct is_monad_monad;
    template<class Policy> struct is_monad_monad<basic_monad<Policy>>
    {
      BOOST_STATIC_CONSTEXPR bool value=is_monad<typename basic_monad<Policy>::value_type>::value;
    };

    template<bool is_monad_monad, class M> struct do_unwrap2;
    template<class M> using do_unwrap = do_unwrap2<is_monad_monad<M>::value, M>;
    template<bool is_monad_monad, class M> struct do_unwrap2
    {
      typedef M input_type;
      typedef input_type output_type;
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(const input_type &v) const { return v; }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(input_type &&v) const { return std::move(v); }
    };
    template<class M> struct do_unwrap2<true, M>
    {
      typedef M input_type;
      typedef typename input_type::value_type unwrapped_type;
      typedef typename do_unwrap<unwrapped_type>::output_type output_type;
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(const input_type &v) const
      {
        if(v.has_error())
          return do_unwrap<unwrapped_type>()(v.get_error());
        else if(v.has_exception())
          return do_unwrap<unwrapped_type>()(v.get_exception());
        else if(v.has_value())
          return do_unwrap<unwrapped_type>()(v.get());
        else
          return do_unwrap<unwrapped_type>()(unwrapped_type());
      }
      BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(input_type &&v) const
      {
        if(v.has_error())
          return do_unwrap<unwrapped_type>()(std::move(v).get_error());
        else if(v.has_exception())
          return do_unwrap<unwrapped_type>()(std::move(v).get_exception());
        else if(v.has_value())
          return do_unwrap<unwrapped_type>()(std::move(v).get());
        else
          return do_unwrap<unwrapped_type>()(unwrapped_type());
      }
    };

    // Is the monad M's contents directly constructible from an R, not allowing a monad<monad<int>> being constructible from an int
    template<class M, class R, bool is_monad_monad=is_monad_monad<M>::value> struct is_monad_constructible : public std::is_constructible<typename M::value_type, R> {};
    template<class M, bool is_monad_monad> struct is_monad_constructible<M, typename M::error_type, is_monad_monad> : public std::true_type{};
    template<class M, bool is_monad_monad> struct is_monad_constructible<M, typename M::exception_type, is_monad_monad> : public std::true_type{};
    template<class M, bool is_monad_monad> struct is_monad_constructible<M, typename M::empty_type, is_monad_monad> : public std::true_type{};
    template<class M> struct is_monad_constructible<M, typename M::value_type::value_type, true> : public std::false_type{};
    template<class F, class M> struct bind_map_parameter_validation
    {
      // Figure out what the callable takes
      typedef traits::callable_argument_traits<F, typename M::value_type> f_value_traits;
      typedef traits::callable_argument_traits<F, typename M::error_type> f_error_traits;
      typedef traits::callable_argument_traits<F, typename M::exception_type> f_exception_traits;
      typedef traits::callable_argument_traits<F, typename M::empty_type> f_empty_traits;
      BOOST_STATIC_CONSTEXPR bool callable_takes_anything=f_value_traits::is_auto;
      BOOST_STATIC_CONSTEXPR bool callable_is_uncallable=!callable_takes_anything && !is_monad<typename M::value_type>::value && (f_value_traits::valid+f_error_traits::valid+f_exception_traits::valid+f_empty_traits::valid)==0;
      BOOST_STATIC_CONSTEXPR bool callable_is_ambiguous=!callable_takes_anything && !is_monad<typename M::value_type>::value && (f_value_traits::valid+f_error_traits::valid+f_exception_traits::valid+f_empty_traits::valid)>1;
      
      // Error out common mistakes in the callable parameter
      static_assert(!callable_is_uncallable,
        "Callable does not have an auto nor templated parameter and is not well formed for none of a value_type, an error_type, an exception_type nor an empty_type. You probably need to adjust the parameter being taken by your callable");
      static_assert(!callable_is_ambiguous,
        "Callable does not have an auto nor templated parameter, yet is well formed for more than one of value_type, error_type, exception_type and empty_type. As cannot disambiguate meaning, stopping");
      static_assert(!f_value_traits::valid || (callable_takes_anything || std::is_convertible<typename f_value_traits::type, typename M::value_type>::value),
        "A value_type consuming callable must have a parameter type which can be implicitly converted to from a value_type, or be an auto or templated parameter");
      static_assert(!f_error_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_error_traits::is_rvalue && std::is_same<typename f_error_traits::type, typename M::error_type>::value),
        "An error_type consuming callable must take an error_type by value");
      static_assert(!f_exception_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_exception_traits::is_rvalue && std::is_same<typename f_exception_traits::type, typename M::exception_type>::value),
        "An exception_type consuming callable must take an exception_type by value");
      static_assert(!f_empty_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_empty_traits::is_rvalue && std::is_same<typename f_empty_traits::type, typename M::empty_type>::value),
        "An empty_type consuming callable must take an empty_type by value");
      
      // Figure out what the callable returns
      using return_type = typename std::conditional<f_value_traits::valid,
        typename f_value_traits::return_type,
        typename std::conditional<f_error_traits::valid,
          typename f_error_traits::return_type,
          typename std::conditional<f_exception_traits::valid,
            typename f_exception_traits::return_type,
            typename std::conditional<f_empty_traits::valid,
              typename f_empty_traits::return_type,
              void
            >::type
          >::type
        >::type
      >::type;

      // Error out common mistakes in the return type
      static_assert(!f_error_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
        "An error_type consuming callable must return a type convertible to the monad type");
      static_assert(!f_exception_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
        "An exception_type consuming callable must return a type convertible to the monad type");
      static_assert(!f_empty_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
        "An empty_type consuming callable must return a type convertible to the monad type");
    };
    
    // Enable calling callable if is well formed and is either not auto or we're doing value_type
    template<class C, class U, class value_type, bool additional=true, class value_type2=void> struct enable_if_callable_valid
      : std::enable_if<additional && traits::callable_argument_traits<C, U>::valid
        && (!traits::callable_argument_traits<C, U>::is_auto || std::is_same<U, value_type>::value || std::is_same<U, value_type2>::value)>
    {};
    template<class C, class U, class value_type, bool additional> struct enable_if_callable_valid<C, U, value_type, additional, void>
      : std::enable_if<additional && traits::callable_argument_traits<C, U>::valid
      && (!traits::callable_argument_traits<C, U>::is_auto || std::is_same<U, value_type>::value)>
    {};
    /* Invokes the callable passed to then() and bind() and map() optionally folding any monad return type
    R is the type returned by the callable
    C is the callable
    M is the monad
    
    Call operator is invoked with any of value, error, exception or empty. If not well
    formed, passes through input.
    */
    template<bool fold_monadic_return, class R, class C, class M> struct do_continuation;
    // For when R is not a monad or map()
    template<bool fold_monadic_return, class R, class C, class Policy> struct do_continuation<fold_monadic_return, R, C, basic_monad<Policy>>
    {
      typedef C callable_type;
      // If the return type is an error_type or exception_type or void, reuse monad else rebind monad to R
      typedef typename std::conditional<std::is_same<R, typename basic_monad<Policy>::error_type>::value
          || std::is_same<R, typename basic_monad<Policy>::exception_type>::value
          || std::is_void<R>::value,
        basic_monad<Policy>,
        typename basic_monad<Policy>::template rebind<R> 
      >::type output_type;
      callable_type _c;
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(const callable_type &c) : _c(c) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &&c) : _c(std::move(c)) { }
      template<class U,
        typename=typename enable_if_callable_valid<C, U, typename basic_monad<Policy>::value_type, !std::is_void<R>::value>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<4>) const
      {
        return traits::callable_argument_traits<C, U>::is_rvalue
          ? output_type(_c(std::move(v)))
          : output_type(_c(U(v)));
      }
      template<class U,
        typename = typename enable_if_callable_valid<C, U, typename basic_monad<Policy>::value_type, std::is_void<R>::value>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<3>) const
      {
        return traits::callable_argument_traits<C, U>::is_rvalue
          ? (_c(std::move(v)), output_type())
          : (_c(U(v)), output_type());
      }
      template<class U, typename=typename std::enable_if<std::is_constructible<output_type, U>::value>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<2>) const { return output_type(std::forward<U>(v)); }
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&, traits::detail::rank<1>) const { return output_type(); }
    };
    // For when R is a monad
    template<class Policy1,
      class C,
      class Policy2> struct do_continuation<true,
        basic_monad<Policy1>,
        C,
        basic_monad<Policy2>
      >
    {
      typedef C callable_type;
      typedef basic_monad<Policy1> output_type;
      typedef basic_monad<Policy2> input_type;
      callable_type _c;
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(const callable_type &c) : _c(c) { }
      BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &&c) : _c(std::move(c)) { }
      template<class U,
        typename = typename enable_if_callable_valid<C, U, input_type, !std::is_void<typename output_type::value_type>::value, typename input_type::value_type>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<4>) const
      {
        return traits::callable_argument_traits<C, U>::is_rvalue
          ? output_type(_c(std::move(v)))
          : output_type(_c(U(v)));
      }
      template<class U,
        typename = typename enable_if_callable_valid<C, U, input_type, std::is_void<typename output_type::value_type>::value, typename input_type::value_type>::type
      > BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<3>) const
      {
        return traits::callable_argument_traits<C, U>::is_rvalue
          ? (_c(std::move(v)), output_type())
          : (_c(U(v)), output_type());
      }
      template<class U, typename=typename std::enable_if<std::is_constructible<output_type, U>::value>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<2>) const { return output_type(std::forward<U>(v)); }
      template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&, traits::detail::rank<1>) const { return output_type(); }
    };

    // TODO FIXME: do_then should have specially reduced simple lightweight implementation
    template<class R, class C, class M> using do_then = do_continuation<true,  R, C, M>;
    template<class R, class C, class M> using do_bind = do_continuation<true,  R, C, M>;
    template<class R, class C, class M> using do_map  = do_continuation<false, R, C, M>;
  }

  //! \brief True if the type passed is a monad or a reference to a monad
  template<class M> struct is_monad : detail::is_monad<typename std::decay<M>::type> { };

  /*! \class basic_monad
  \brief Implements a configurable lightweight simple monadic value transport with the same semantics and API as a future
  \tparam implementation_policy An implementation policy type
  
  Predefined basic_monad implementations:
  - `monad<R>` can hold a fixed variant list of empty, a type `R`, a lightweight `std::error_code` or a
  heavier `std::exception_ptr` at a space cost of `max(20, sizeof(R)+4)`. This corresponds to `tribool::false_`,
  `tribool::true_`, `tribool::unknown` and `tribool::unknown` respectively. 
  - `result<R>` can hold a fixed variant list of empty, a type `R` or a lightweight `std::error_code` at a
  space cost of `max(20, sizeof(R)+4)`. This corresponds to `tribool::false_`, `tribool::true_` and
  `tribool::unknown` respectively. This specialisation looks deliberately like Rust's `Result<T>`.
  - `option<R>` can hold a fixed variant list of empty or a type `R` at a space cost of `sizeof(value_storage<R>)`
  which is usually `sizeof(R)+4`, but may be smaller if `value_storage<R>` is specialised. This
  corresponds to `tribool::false_` and `tribool::true_` respectively. This specialisation looks deliberately
  like Rust's `Option<T>`.

Features:

  - Very lightweight on build times and run times up to the point of zero execution cost and just a four
  byte space overhead. See below for benchmarks. Requires min clang 3.2, GCC 4.7 or VS2015.
  - Just enough monad, nothing more, nothing fancy. Replicates the future API, so if you know how to
  use a future you already know how to use this.
  - Enables convenient all-`noexcept` mathematically verifiable close semantic design, so
  why bother with Rust anymore? :)
  - Can replace most uses of `optional<T>`.
  - Deep integration with lightweight future-promise (i.e. async monadic programming) also in this library.
  - Comprehensive unit testing and validation suite.
  - Mirrors `noexcept` of type R.
  - Type R can have no default constructor, move nor copy.
  - Works inside a STL container, and type R can be a STL container.
    - No comparison operations nor hashing is provided, deliberately to keep things simple.

## Notes: ##

  As `monad<R>`, `result<R>` and `option<R>` are all just `basic_monad` with different implementation
  policies, wherever we refer to `monad<R>` we mean those three specialisations as well.

  Something which might surprise people is that:

  \code
  monad<std::string> a("niall");
  monad<std::string> b(std::move(a));
  BOOST_CHECK(a.has_value());  // true
  \endcode

  Moving a monad does a move of its underlying contents, so any contents remain at whatever
  the move constructor for that content leaves things. In other words, a moved from monad
  does not become empty, if you want that then call clear().

  So long as you avoid the exception_type code paths (`result<R>`, `option<R>`), this implementation will be
  ideally reduced to as few assembler instructions as possible by most recent compilers [1]
  which can include exactly zero assembler instructions output. This monad is therefore
  identical in terms of execution overhead to using the R type you specify directly - you
  get the monadic functionality totally free of execution overhead where the compiler is able
  to reduce it to such.

  A similar thing applies to error_type which is a lightweight implementation on most
  systems. An exception is on VS2015 as the lvalue reference to system_category appears
  to be constructed via thread safe once routine called "Immortalize", so when you
  construct an error_type on MSVC you'll force a memory synchronisation during the constructor
  only. error_types are very cheap to pass around though as they are but an integer and a lvalue ref,
  though I see that on GCC and clang 16 bytes is always copied around instead of completely
  eliding the copy.

  exception_type is also pretty good on anything but MSVC, though never zero assembler
  instructions. As soon as an exception_type \em could be created, you'll force out about twenty
  instructions most of which won't be executed in practice. Unfortunately, MSVC churns out
  about 2000 assembler instructions as soon as you might touch an exception_type, I've raised
  this with Microsoft and it looks to be hard for them to fix due to backwards compatibility
  reasons.

  [1]: GCC 5.1 does a perfect job, VS2015 does a good job, clang 3.7 not so great. See next section.

## Complexity guarantees ##

  These x64 opcode guarantees are empirically determined by the unit test suite, and the per-commit
  CI testing will fail if they suddenly are exceeded. The maximum is calculated by taking a monad
  in from a non-visible source where the compiler has to generate code paths to handle an unknown
  input state, whereas the minimum is calculated by setting a monad's state in view of the compiler's
  optimiser such that it can usually completely elide opcodes generated (though note that varies
  enormously by compiler to the extent that the known code generates more opcodes than the unknown code). All monads are `monad<int>`.

### `monad<R>`: ###
  <dl>
   <dt>clang 3.7</dt>
    <dd>59 opcodes <= Value transport <= 37 opcodes<br></dd>
    <dd>7 opcodes <= Error transport <= 52 opcodes<br></dd>
    <dd>38 opcodes <= Exception transport <= 39 opcodes<br></dd>  
    <dd>62 opcodes <= then() <= 84 opcodes<br></dd>
    <dd>5 opcodes <= bind() <= 44 opcodes</dd>
   <dt>GCC 5.1</dt>
    <dd>1 opcodes <= Value transport <= 113 opcodes<br></dd>
    <dd>8 opcodes <= Error transport <= 119 opcodes<br></dd>
    <dd>22 opcodes <= Exception transport <= 214 opcodes<br></dd>
    <dd>4 opcodes <= then() <= 154 opcodes<br></dd>
    <dd>5 opcodes <= bind() <= 44 opcodes</dd>
   <dt>VS2015</dt>
    <dd>4 opcodes <= Value transport <= 1881 opcodes<br></dd>
    <dd>6 opcodes <= Error transport <= 164 opcodes<br></dd>
    <dd>1946 opcodes <= Exception transport <= 1936 opcodes<br></dd>
    <dd>2029 opcodes <= then() <= 2030 opcodes<br></dd>
    <dd>155 opcodes <= bind() <= 156 opcodes</dd>
  </dl>

### `result<R>`: ###
TODO

### `option<R>`: ###
TODO

## Examples ##

  \snippet unittests.cpp monad_example

### As an alternative to `optional<T>` ###

  Something not so obvious is that this monad can have an empty state, and therefore
  can stand in for `optional<T>` like this:

  \snippet unittests.cpp optional_example

  The API is actually not too distant from `optional<T>`, so with a bit of regex find and replace
  you could use `option<T>` instead.

  The need for `monad<T>` to be able to be empty was to make exception throws by T during copy and move
  construction lightweight. If that happens, the monad always has empty state afterwards.
  
## Supplying your own implementations of `basic_monad<T>` ##
  To do this, simply supply a policy type of the following form:
  \snippet monad.hpp monad_policy
  */
  template<class implementation_policy> class basic_monad
  {
    friend implementation_policy;
  protected:
    typedef value_storage<implementation_policy> value_storage_type;
    value_storage_type _storage;
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(value_storage_type &&s) : _storage(std::move(s)) { }
  public:
    //! \brief This monad has a value_type
    BOOST_STATIC_CONSTEXPR bool has_value_type = value_storage_type::has_value_type;
    //! \brief This monad has an error_type
    BOOST_STATIC_CONSTEXPR bool has_error_type = value_storage_type::has_error_type;
    //! \brief This monad has an exception_type
    BOOST_STATIC_CONSTEXPR bool has_exception_type = value_storage_type::has_exception_type;
    //! \brief The final implementation type
    typedef typename value_storage_type::implementation_type implementation_type;
    //! \brief The type potentially held by the monad
    typedef typename value_storage_type::value_type value_type;
    //! \brief The error code potentially held by the monad
    typedef typename value_storage_type::error_type error_type;
    //! \brief The exception ptr potentially held by the monad
    typedef typename value_storage_type::exception_type exception_type;
    //! \brief Tag type for an empty monad
    struct empty_type { typedef implementation_type parent_type; };
    //! \brief Rebind this monad type into a different value_type
    template<typename U> using rebind = typename implementation_policy::template rebind<U>;

    static_assert(!std::is_same<value_type, error_type>::value, "R and error_type cannot be the same type");
    static_assert(!std::is_same<value_type, exception_type>::value, "R and exception_type cannot be the same type");
    static_assert(!std::is_same<error_type, exception_type>::value, "error_type and exception_type cannot be the same type");

    //! \brief This monad will never throw exceptions during copy construction
    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_constructible = value_storage_type::is_nothrow_copy_constructible;
    //! \brief This monad will never throw exceptions during move construction
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_constructible = value_storage_type::is_nothrow_move_constructible;
    //! \brief This monad will never throw exceptions during copy assignment
    BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_assignable = value_storage_type::is_nothrow_destructible && value_storage_type::is_nothrow_copy_constructible;
    //! \brief This monad will never throw exceptions during move assignment
    BOOST_STATIC_CONSTEXPR bool is_nothrow_move_assignable = value_storage_type::is_nothrow_destructible && value_storage_type::is_nothrow_move_constructible;
    //! \brief This monad will never throw exceptions during destruction
    BOOST_STATIC_CONSTEXPR bool is_nothrow_destructible = value_storage_type::is_nothrow_destructible;

    //! \brief Default constructor, initialises to empty
    basic_monad() = default;
    //! \brief Implicit constructor of an empty monad
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(empty_type) : basic_monad() { }
    //! \brief Implicit constructor from a value_type by copy
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value) : _storage(v) { }
    //! \brief Implicit constructor from a value_type by move
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value) : _storage(std::move(v)) { }
    /*! \brief Explicit constructor of a value_type allowing emplacement with no other means of construction. Only available
    if value_type which can't be a monad can be constructed from Args and if either there is more than one Arg or the Arg is not a value_type, an
    error_type, an exception_type nor an empty_type.
    */
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class... Args> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit basic_monad(Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Arg, Args...>::value);
#else
    template<class Arg, class... Args,
      typename = typename std::enable_if<has_value_type &&
        !is_monad<value_type>::value
        && std::is_constructible<value_type, Arg, Args...>::value
        && (sizeof...(Args)!=0 || 
          (!std::is_same<value_type, typename std::decay<Arg>::type>::value
          && !std::is_same<error_type, typename std::decay<Arg>::type>::value
          && !std::is_same<exception_type, typename std::decay<Arg>::type>::value
          && !std::is_same<empty_type, typename std::decay<Arg>::type>::value))
      >::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit basic_monad(Arg &&arg, Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Arg, Args...>::value) : _storage(typename value_storage_type::emplace_t(), std::forward<Arg>(arg), std::forward<Args>(args)...) { }
#endif
    //! \brief Implicit constructor from an initializer list
    template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(std::initializer_list<U> l) noexcept(std::is_nothrow_constructible<value_type, std::initializer_list<U>>::value) : _storage(typename value_storage_type::emplace_t(), std::move(l)) { }
    //! \brief Implicit constructor from a error_type by copy
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(const error_type &v) noexcept(std::is_nothrow_copy_constructible<error_type>::value) : _storage(v) { }
    //! \brief Implicit constructor from a error_type by move
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(error_type &&v) noexcept(std::is_nothrow_move_constructible<error_type>::value) : _storage(std::move(v)) { }
    //! \brief Implicit constructor from a exception_type by copy
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(const exception_type &v) noexcept(std::is_nothrow_copy_constructible<exception_type>::value) : _storage(v) { }
    //! \brief Implicit constructor from a exception_type by move
    BOOST_SPINLOCK_FUTURE_CONSTEXPR basic_monad(exception_type &&v) noexcept(std::is_nothrow_move_constructible<exception_type>::value) : _storage(std::move(v)) { }
    //! \brief Move constructor
    basic_monad(basic_monad &&) = default;
    //! \brief Move assignment. Firstly clears any existing state, so exception throws during move will leave the monad empty.
    basic_monad &operator=(basic_monad &&) = default;
    //! \brief Copy constructor
    basic_monad(const basic_monad &v) = default;
    //! \brief Copy assignment. Firstly clears any existing state, so exception throws during copy will leave the monad empty.
    basic_monad &operator=(const basic_monad &) = default;

    //! \brief Same as `true_(tribool(*this))`
    BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit operator bool() const noexcept { return has_value(); }
    //! \brief True if monad contains a value_type, false if monad is empty, else unknown.
    BOOST_SPINLOCK_FUTURE_CONSTEXPR operator tribool::tribool() const noexcept { return has_value() ? tribool::tribool::true_ : empty() ? tribool::tribool::false_ : tribool::tribool::unknown; }
    //! \brief True if monad is not empty
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool is_ready() const noexcept
    {
      return _storage.type!=value_storage_type::storage_type::empty;
    }
    //! \brief True if monad is empty
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool empty() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::empty;
    }
    //! \brief True if monad contains a value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_value() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::value;
    }
    //! \brief True if monad contains an error_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_error() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::error;
    }
    //! \brief True if monad contains an exception_type or error_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_exception() const noexcept
    {
      return _storage.type==value_storage_type::storage_type::exception || _storage.type==value_storage_type::storage_type::error;
    }

    //! \brief Swaps one monad for another
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void swap(basic_monad &o) noexcept(is_nothrow_move_constructible)
    {
      _storage.swap(o._storage);
    }
    //! \brief Destructs any state stored, resetting to empty
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void clear() noexcept(is_nothrow_destructible)
    {
      _storage.clear();
    }

    //! \brief If contains a value_type, returns a lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &get() &
    {
      implementation_policy::_pre_get_value(this);
      return _storage.value;
    }
    //! \brief If contains a value_type, returns a lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &value() &
    {
      implementation_policy::_pre_get_value(this);
      return _storage.value;
    }
    //! \brief If contains a value_type, returns a const lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &get() const &
    {
      implementation_policy::_pre_get_value(this);
      return _storage.value;
    }
    //! \brief If contains a value_type, returns a const lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &value() const &
    {
      implementation_policy::_pre_get_value(this);
      return _storage.value;
    }
    //! \brief If contains a value_type, returns a rvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&get() &&
    {
      implementation_policy::_pre_get_value(this);
      return std::move(_storage.value);
    }
    //! \brief If contains a value_type, returns a rvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&value() &&
    {
      implementation_policy::_pre_get_value(this);
      return std::move(_storage.value);
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &get_or(value_type &v) & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &value_or(value_type &v) & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &get_or(const value_type &v) const & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &value_or(const value_type &v) const & noexcept
    {
      return has_value() ? _storage.value : v;
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&get_or(value_type &&v) && noexcept
    {
      return has_value() ? std::move(_storage.value) : std::move(v);
    }
    //! \brief If contains a value_type, return that value type, else return the supplied value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&value_or(value_type &&v) && noexcept
    {
      return has_value() ? std::move(_storage.value) : std::move(v);
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &get_and(value_type &v) & noexcept
    {
      return has_value() ? v: _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &value_and(value_type &v) & noexcept
    {
      return has_value() ? v : _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &get_and(const value_type &v) const & noexcept
    {
      return has_value() ? v: _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &value_and(const value_type &v) const & noexcept
    {
      return has_value() ? v: _storage.value;
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&get_and(value_type &&v) && noexcept
    {
      return has_value() ? std::move(v) : std::move(_storage.value);
    }
    //! \brief If contains a value_type, return the supplied value_type else return the contained value_type
    BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&value_and(value_type &&v) && noexcept
    {
      return has_value() ? std::move(v) : std::move(_storage.value);
    }
    //! \brief Disposes of any existing state, setting the monad to a copy of the value_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(const value_type &v) { _storage.clear(); _storage.set_value(v); }
    //! \brief Disposes of any existing state, setting the monad to a move of the value_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(value_type &&v) { _storage.clear(); _storage.set_value(std::move(v)); }
    //! \brief Disposes of any existing state, setting the monad to a default value
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value() { _storage.clear(); _storage.set_value(value_type()); }
    //! \brief Disposes of any existing state, setting the monad to an emplaced construction
    template<class... Args> BOOST_SPINLOCK_FUTURE_MSVC_HELP void emplace(Args &&... args) { _storage.clear(); _storage.emplace_value(std::forward<Args>(args)...); }
    
    //! \brief If contains an error_type, returns that error_type, else returns a null error_type. Can only throw the exception monad_error(no_state) if empty.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error() const
    {
      if(!is_ready())
      {
        if(!implementation_policy::_throw_error(monad_errc::no_state))
          return error_type();
      }
      if(!has_error())
        return error_type();
      return _storage.error;
    }
    //! \brief If contains an error_type, returns that error_type else returns the error_type supplied
    BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error_or(error_type e) const noexcept { return has_error() ? _storage.error : std::move(e); }
    //! \brief If contains an error_type, return the supplied error_type else return the contained error_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error_and(error_type e) const noexcept { return has_error() ? std::move(e) : _storage.error; }
    //! \brief Disposes of any existing state, setting the monad to the error_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_error(error_type v) { _storage.clear(); _storage.set_error(std::move(v)); }
    
    //! \brief If contains an exception_type, returns that exception_type. If contains an error_type, returns system_error(error_type). If contains a value_type, returns a null exception_type. Can only throw the exception monad_error(no_state) if empty.
    BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception() const
    {
      if(!is_ready())
      {
        if(!implementation_policy::_throw_error(monad_errc::no_state))
          return exception_type();
      }
      if(!has_error() && !has_exception())
        return exception_type();
      if(has_error())
        return implementation_policy::_to_exception_type(_storage.error);
      if(has_exception())
        return _storage.exception;
      return exception_type();
    }
    //! \brief If contains an exception_type, returns that exception_type else returns the exception_type supplied
    BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception_or(exception_type e) const noexcept { return has_exception() ? _storage.exception : std::move(e); }
    //! \brief If contains an exception_type, return the supplied exception_type else return the contained exception_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception_and(exception_type e) const noexcept { return has_exception() ? std::move(e) : _storage.exception; }
    //! \brief Disposes of any existing state, setting the monad to the exception_type
    BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_exception(exception_type v) { _storage.clear(); _storage.set_exception(std::move(v)); }
    //! \brief Disposes of any existing state, setting the monad to make_exception_type(forward<E>(e))
    template<typename E> BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_exception(E &&e)
    {
      set_exception(make_exception_type(std::forward<E>(e)));
    }

    /*! \name Monadic programming primitives unwrap(), then(), bind() and map()
    
    Classic monadic programming consists of a sequence of nested functional operations:
    <dl>
      <dt>JOIN (single): monad<monad<T>>.get() -> monad<T></dt>
      <dt>JOIN (maximum): monad<monad<monad<monad<T>>>>.unwrap() -> monad<T></dt>
        <dd>Whatever is the first monad containing a non-monad is returned.</dd>
      <dt>MAP: monad<T>.map(R(T)) -> monad<R></dt>
        <dd>If callable maps T to R, map() maps a monad<T> to a monad<R> if monad<T>
        contains a T. If it contains an error or is empty, that is passed through.</dd>
      <dt>BIND: monad<T>.bind(monad<R>(T)) -> monad<R></dt>
      <dt>BIND: monad<T>.bind(R(T)) -> monad<R></dt>
        <dd>If callable maps T to monad<R> and if monad<T> contains a T, then bind() maps
        a monad<T> to a monad<R> else if callable maps T to R and if monad<T> contains a T,
        bind() maps a monad<T> to a monad<R>. In other words, returning a monad from the
        callable does not wrap it in another monad. If the originating monad did not
        contain a T, that is passed through.</dd>
    </dl>
    We also support monad<T>.then(R(monad<T>)) for semantic equivalence to futures where the
    callable is called with the originating monad. This
    acts like bind(), so if the callable returns a monad it is not wrapped in another
    monad. Unlike map() or bind(), then() always calls the callable no matter what the
    monad contains, so it is up to you to interrogate the monad. Note that the originating
    monad is passed by const lvalue ref unless the callable takes a rvalue ref to the monad.
    
    A quick use example:
    \snippet monad_example.cpp monad_bind_example
    
    You will note in the code example that the type of the callable for bind() and map()
    determines what operation happens. Here are the rules:
    - If the monad contains a T and the callable takes a T or an `auto`, then:
      - If the callable takes a T or any reference to a T which isn't an rvalue reference,
      the T is passed by const lvalue reference (i.e. copy semantics).
      - If the callable takes a T by non-const rvalue reference, the T is passed by rvalue ref.
      This lets you move from the value held by the originating monad if so desired.
    If the monad doesn't contain a T, pass it through but into whatever new monad type
    returned by the callable.
    \warning The current implementation requires you to specify a non-dependent return
    type for all generic lambdas, else you'll get compile errors where the compiler tried
    to insert `error_type`, `exception_type` etc when it was trying to figure out if the
    return type is correct. A future implementation (once VS2015 has Expression SFINAE) may
    remove this restriction, until then just hard specify your return types if your lambdas
    take an `auto`, or use lambdas not taking `auto`.
    
    - If the monad contains an `error_type` and the callable takes an `error_type`, then
    call the callable, else pass through the monad. For this reason, any callable taking
    an `error_type` must always return the same monad type as the originating monad.
    - If the monad contains an `error_type` or an `exception_type` and the callable takes
    an `exception_type`, then call the callable, else pass through the monad. For this reason,
    any callable taking an `exception_type` must always return the same monad type as the
    originating monad.
    - If the monad is empty and the callable takes an `empty_type`, then call the callable,
    else pass through the monad. For this reason, any callable with an `empty_type` parameter must
    always return the same monad type as the originating monad.

    Note that for nested monads e.g. monad<monad<int>>, either or both of the inner or outer
    monads can be with value or with error or empty. You should have your binds and maps
    work appropriately.
    
    For maximum build performance, try to avoid bind() and map() as these use some hefty
    metaprogramming to deduce what kind of bind and map you're doing based on the callables
    passed. unwrap() is implemented using a recursively expanded structure which is probably
    okay for low unwrap depths. then() is probably the least weighty of the monadic operators
    as it's relatively dumb and the only metaprogramming is to determine whether to wrap
    the return type with a monad or not.
    
  ### Acknowledgements ###
    To T.C. on Stack Overflow for answering my question at https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference
    and without whose excellent answer the intelligent map() and bind() above could not work.
    */
    ///@{
    //! \brief If I am a monad<monad<...>>, return copy of most nested monad<...>, else return copy of *this
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    monad<...> unwrap() const &;
#else
    BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_unwrap<basic_monad>::output_type unwrap() const & { return detail::do_unwrap<basic_monad>()(*this); }
#endif
    //! \brief If I am a monad<monad<...>>, return move of most nested monad<...>, else return move of *this
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    monad<...> unwrap() &&;
#else
    BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_unwrap<basic_monad>::output_type unwrap() && { return detail::do_unwrap<basic_monad>()(std::move(*this)); }
#endif

    /*! \brief Return basic_monad(F(*this)) or F(*this) if the latter returns a monad.
    
    The callable F needs to consume a monad obviously enough, however if your callable takes a monad &&, you can move
    from the monad. Equally, you can avoid copies if your
    callable takes a reference argument. The callable F can be a generic lambda if desired.
    
    If your callable does not return a monad, a monad will be constructed to hold the type it does return
    inheriting the same error_code, exception_type etc of the originating monad. If your callable returns
    a monad, that monad can be of any template parameter configuration and it will be returned from then(). This
    allows a very easy way of converting between different configurations of monad cost free.
    */
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> basic_monad(F(*this)).unwrap() then(F &&f);
#else
    template<class F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_then<typename traits::is_callable_is_well_formed<F, basic_monad>::type, F, basic_monad>::output_type then(F &&f)
    {
      typedef traits::callable_argument_traits<F, basic_monad> f_traits;
      static_assert(f_traits::valid,
        "The callable passed to then() must take this monad type or a reference to it.");
      return detail::do_then<typename f_traits::return_type, F, basic_monad>(std::forward<F>(f))(std::move(*this), traits::detail::rank<5>());
    }
#endif
    
    //! \brief If bool(*this), return basic_monad(F(get())).unwrap(), else return basic_monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> basic_monad(F(get())).unwrap() bind(F &&f);
#else
    template<class F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_bind<typename detail::bind_map_parameter_validation<F, basic_monad>::return_type, F, basic_monad>::output_type bind(F &&f)
    {
      typedef detail::do_bind<typename detail::bind_map_parameter_validation<F, basic_monad>::return_type, F, basic_monad> impl;
      if(has_value())
        return impl(std::forward<F>(f))(std::move(_storage.value), traits::detail::rank<5>());
      else if(has_error())
        return impl(std::forward<F>(f))(std::move(_storage.error), traits::detail::rank<5>());
      else if(has_exception())
        return impl(std::forward<F>(f))(std::move(_storage.exception), traits::detail::rank<5>());
      else
        return impl(std::forward<F>(f))(empty_type(), traits::detail::rank<5>());
    }
#endif
    
    //! \brief If bool(*this), return basic_monad(F(get())), else return basic_monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
    template<class F> basic_monad(F(get())) map(F &&f);
#else
    template<class F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_map<typename detail::bind_map_parameter_validation<F, basic_monad>::return_type, F, basic_monad>::output_type map(F &&f)
    {
      typedef detail::do_map<typename detail::bind_map_parameter_validation<F, basic_monad>::return_type, F, basic_monad> impl;
      if(has_value())
        return impl(std::forward<F>(f))(std::move(_storage.value), traits::detail::rank<5>());
      else if(has_error())
        return impl(std::forward<F>(f))(std::move(_storage.error), traits::detail::rank<5>());
      else if(has_exception())
        return impl(std::forward<F>(f))(std::move(_storage.exception), traits::detail::rank<5>());
      else
        return impl(std::forward<F>(f))(empty_type(), traits::detail::rank<5>());
    }
#endif
  ///@}
  };
  
  namespace detail
  {
    //! [monad_policy]
    template<typename R> struct monad_policy
    {
      // The final resulting implementation type
      typedef basic_monad<monad_policy> implementation_type;
      // The value type to use. Can be void to disable.
      typedef R value_type;
      // The error code type to use. Can be void to disable.
      typedef std::error_code error_type;
      // The exception pointer type to use. Can be void to disable.
      typedef std::exception_ptr exception_type;
      // Used by basic_future only, otherwise leave as void.
      typedef void pointer_type;
      // The type which basic_monad::rebind<U> should return
      template<typename U> using rebind = basic_monad<monad_policy<U>>;
      // Must handle error situation ec. Can return false to cancel the calling operation.
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP bool _throw_error(monad_errc ec)
      {
        throw monad_error(ec);
      }
      // Called before get()/value() returns any value_type.
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _pre_get_value(U *self)
      {
        if(!self->is_ready())
          _throw_error(monad_errc::no_state);
        if(self->has_error() || self->has_exception())
        {
          if(self->has_error())
            throw std::system_error(self->_storage.error);
          if(self->has_exception())
            std::rethrow_exception(self->_storage.exception);
        }      
      }
      // Called to convert an error_type to an exception_type
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type _to_exception_type(error_type e)
      {
        return std::make_exception_ptr(std::system_error(e));
      }    
    };
    //! [monad_policy]
    
    template<typename R> struct result_policy
    {
      typedef basic_monad<result_policy> implementation_type;
      typedef R value_type;
      typedef std::error_code error_type;
      typedef void exception_type;
      typedef void pointer_type;
      template<typename U> using rebind = basic_monad<result_policy<U>>;
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP bool _throw_error(monad_errc ec)
      {
        throw monad_error(ec);
      }
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _pre_get_value(U *self)
      {
        if(!self->is_ready())
          _throw_error(monad_errc::no_state);
        if(self->has_error())
          throw std::system_error(self->_storage.error);
      }
      //static BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type _to_exception_type(error_type e)
    };

    template<typename R> struct option_policy
    {
      typedef basic_monad<option_policy> implementation_type;
      typedef R value_type;
      typedef void error_type;
      typedef void exception_type;
      typedef void pointer_type;
      template<typename U> using rebind = basic_monad<option_policy<U>>;
      static BOOST_SPINLOCK_FUTURE_MSVC_HELP bool _throw_error(monad_errc ec)
      {
        throw monad_error(ec);
      }
      template<class U> static BOOST_SPINLOCK_FUTURE_MSVC_HELP void _pre_get_value(U *self)
      {
        if(!self->is_ready())
          _throw_error(monad_errc::no_state);
      }
      //static BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type _to_exception_type(error_type e)
    };
  }

  /*! \brief `monad<R>` can hold a fixed variant list of empty, a type `R`, a lightweight `std::error_code` or a
  heavier `std::exception_ptr` at a space cost of `max(20, sizeof(R)+4)`. This corresponds to `tribool::false_`,
  `tribool::true_`, `tribool::unknown` and `tribool::unknown` respectively.
  */
  template<typename R> using monad = basic_monad<detail::monad_policy<R>>;
  /*! \brief `result<R>` can hold a fixed variant list of empty, a type `R` or a lightweight `std::error_code` at a
  space cost of `max(20, sizeof(R)+4)`. This corresponds to `tribool::false_`, `tribool::true_` and
  `tribool::unknown` respectively. This specialisation looks deliberately like Rust's `Result<T>`.
  */
  template<typename R> using result = basic_monad<detail::result_policy<R>>;
  /*! \brief `option<R>` can hold a fixed variant list of empty or a type `R` at a space cost of `sizeof(value_storage<R>)`
  which is usually `sizeof(R)+4`, but may be smaller if `value_storage<R>` is specialised. This
  corresponds to `tribool::false_` and `tribool::true_` respectively. This specialisation looks deliberately
  like Rust's `Option<T>`.
  */
  template<typename R> using option = basic_monad<detail::option_policy<R>>;

  //! \brief Makes a monad from the type passed
  template<class T> monad<T> make_monad(T &&v) { return monad<T>(std::forward<T>(v)); }
  //! \brief Makes an errored monad of type T
  template<class T> monad<T> make_monad(std::error_code v) { return monad<T>(std::move(v)); }
  //! \brief Makes an excepted monad of type T
  template<class T> monad<T> make_monad(std::exception_ptr v) { return monad<T>(std::move(v)); }
  //! \brief Makes an empty monad of type T
  template<class T> monad<T> make_monad() { return monad<T>(); }
}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
  template<class Impl> inline void swap(BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::basic_monad<Impl> &a, BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::basic_monad<Impl> &b)
  {
    a.swap(b);
  }
}

#endif
