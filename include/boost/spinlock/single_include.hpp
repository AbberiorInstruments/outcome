/* THIS IS AN AUTOMATICALLY GENERATED FILE, DO NOT EDIT! */
#define SPINLOCK_STANDALONE 1
#define BOOST_SPINLOCK_DISABLE_VALGRIND 1
/* Begin /home/ned/boost.spinlock/include/boost/spinlock/future.hpp */
/* future.hpp
Non-allocating constexpr future-promise
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: May 2015

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_SPINLOCK_FUTURE_HPP
#define BOOST_SPINLOCK_FUTURE_HPP

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/monad.hpp */
/* monad.hpp
The world's most simple C++ monad
(C) 2015 Niall Douglas http://www.nedprod.com/
File Created: June 2015

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_SPINLOCK_MONAD_HPP
#define BOOST_SPINLOCK_MONAD_HPP

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */
/* spinlock.hpp
Provides yet another spinlock
(C) 2013-2014 Niall Douglas http://www.nedprod.com/
File Created: Sept 2013

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_SPINLOCK_HPP
#define BOOST_SPINLOCK_HPP

#include <assert.h>
#include <vector>
#include <memory>
#include <array>

#ifdef BOOST_SPINLOCK_ENABLE_VALGRIND
#include "valgrind/drd.h"
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_CREATE(p) ANNOTATE_RWLOCK_CREATE(p)
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_DESTROY(p) ANNOTATE_RWLOCK_DESTROY(p)
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_ACQUIRED(p, s) ANNOTATE_RWLOCK_ACQUIRED(p, s)
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_RELEASED(p, s) ANNOTATE_RWLOCK_RELEASED(p, s)
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_READS_BEGIN() ANNOTATE_IGNORE_READS_BEGIN()
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_READS_END() ANNOTATE_IGNORE_READS_END()
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_WRITES_BEGIN() ANNOTATE_IGNORE_WRITES_BEGIN()
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_WRITES_END() ANNOTATE_IGNORE_WRITES_END()
#define BOOST_SPINLOCK_DRD_IGNORE_VAR(x) DRD_IGNORE_VAR(x)
#define BOOST_SPINLOCK_DRD_STOP_IGNORING_VAR(x) DRD_STOP_IGNORING_VAR(x)
#define BOOST_SPINLOCK_RUNNING_ON_VALGRIND RUNNING_ON_VALGRIND
#else
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_CREATE(p)
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_DESTROY(p)
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_ACQUIRED(p, s)
#define BOOST_SPINLOCK_ANNOTATE_RWLOCK_RELEASED(p, s)
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_READS_BEGIN()
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_READS_END()
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_WRITES_BEGIN()
#define BOOST_SPINLOCK_ANNOTATE_IGNORE_WRITES_END()
#define BOOST_SPINLOCK_DRD_IGNORE_VAR(x)
#define BOOST_SPINLOCK_DRD_STOP_IGNORING_VAR(x)
#define BOOST_SPINLOCK_RUNNING_ON_VALGRIND (0)
#endif

/*! \file spinlock.hpp
\brief Provides boost.spinlock
*/

/*! \mainpage
This is the proposed Boost.Spinlock library, a Boost C++ 11 library providing interesting spinlock related things.
*/

#if SPINLOCK_STANDALONE
/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/boost/config.hpp */
/* boostmacros.hpp
Provides lightweight Boost macros
(C) 2014 Niall Douglas http://www.nedprod.com/
File Created: Aug 2014

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_BINDLIB_BOOST_MACROS_HPP
#define BOOST_BINDLIB_BOOST_MACROS_HPP

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/boost/../cpp_feature.h */
/* has_feature.h
Provides SG-10 feature checking for all C++ compilers
(C) 2014 Niall Douglas http://www.nedprod.com/
File Created: Nov 2014

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_BINDLIB_HAS_FEATURE_H
#define BOOST_BINDLIB_HAS_FEATURE_H

// VS2010: _MSC_VER=1600
// VS2012: _MSC_VER=1700
// VS2013: _MSC_VER=1800
// VS2015: _MSC_VER=1900
#ifdef _MSC_VER

#if !defined(__cpp_exceptions) && defined(_CPPUNWIND)
# define __cpp_exceptions 190000
#endif

#if !defined(__cpp_rtti) && defined(_CPPRTTI)
# define __cpp_rtti 190000
#endif

// C++ 11
//#if !defined(__cpp_access_control_sfinae)
//# define __cpp_access_control_sfinae 190000
//#endif

#if !defined(__cpp_alias_templates) && _MSC_VER >= 1800
# define __cpp_alias_templates 190000
#endif

#if !defined(__cpp_alignas) && _MSC_VER >= 1900
# define __cpp_alignas 190000
#endif

//#if !defined(__cpp_attributes)
//# define __cpp_attributes 190000
//#endif

//#if !defined(__cpp_constexpr)
//# define __cpp_constexpr 190000
//#endif

#if !defined(__cpp_decltype) && _MSC_VER >= 1600
# define __cpp_decltype 190000
#endif

#if !defined(__cpp_default_function_template_args) && _MSC_VER >= 1800
# define __cpp_default_function_template_args 190000
#endif

#if !defined(__cpp_defaulted_functions) && _MSC_VER >= 1800
# define __cpp_defaulted_functions 190000
#endif

#if !defined(__cpp_delegating_constructors) && _MSC_VER >= 1800
# define __cpp_delegating_constructors 190000
#endif

#if !defined(__cpp_deleted_functions) && _MSC_VER >= 1800
# define __cpp_deleted_functions 190000
#endif

#if !defined(__cpp_explicit_conversions) && _MSC_VER >= 1800
# define __cpp_explicit_conversions 190000
#endif

#if !defined(__cpp_generalized_initializers) && _MSC_VER >= 1800
# define __cpp_generalized_initializers 190000
#endif

#if !defined(__cpp_implicit_moves) && _MSC_VER >= 1900
# define __cpp_implicit_moves 190000
#endif

#if !defined(__cpp_inheriting_constructors) && _MSC_VER >= 1900
# define __cpp_inheriting_constructors 190000
#endif

#if !defined(__cpp_inline_namespaces) && _MSC_VER >= 1900
# define __cpp_inline_namespaces 190000
#endif

#if !defined(__cpp_lambdas) && _MSC_VER >= 1600
# define __cpp_lambdas 190000
#endif

#if !defined(__cpp_local_type_template_args) && _MSC_VER >= 1600
# define __cpp_local_type_template_args 190000
#endif

#if !defined(__cpp_noexcept) && _MSC_VER >= 1900
# define __cpp_noexcept 190000
#endif

#if !defined(__cpp_nonstatic_member_init) && _MSC_VER >= 1800
# define __cpp_nonstatic_member_init 190000
#endif

#if !defined(__cpp_nullptr) && _MSC_VER >= 1600
# define __cpp_nullptr 190000
#endif

#if !defined(__cpp_override_control) && _MSC_VER >= 1700
# define __cpp_override_control 190000
#endif

#if !defined(__cpp_reference_qualified_functions) && _MSC_VER >= 1900
# define __cpp_reference_qualified_functions 190000
#endif

#if !defined(__cpp_range_for) && _MSC_VER >= 1700
# define __cpp_range_for 190000
#endif

#if !defined(__cpp_raw_strings) && _MSC_VER >= 1800
# define __cpp_raw_strings 190000
#endif

#if !defined(__cpp_rvalue_references) && _MSC_VER >= 1600
# define __cpp_rvalue_references 190000
#endif

#if !defined(__cpp_static_assert) && _MSC_VER >= 1600
# define __cpp_static_assert 190000
#endif

#if !defined(__cpp_thread_local) && _MSC_VER >= 1900
# define __cpp_thread_local 190000
#endif

#if !defined(__cpp_auto_type) && _MSC_VER >= 1600
# define __cpp_auto_type 190000
#endif

#if !defined(__cpp_strong_enums) && _MSC_VER >= 1700
# define __cpp_strong_enums 190000
#endif

#if !defined(__cpp_trailing_return) && _MSC_VER >= 1600
# define __cpp_trailing_return 190000
#endif

//#if !defined(__cpp_unicode_literals)
//# define __cpp_unicode_literals 190000
//#endif

#if !defined(__cpp_unrestricted_unions) && _MSC_VER >= 1900
# define __cpp_unrestricted_unions 190000
#endif

#if !defined(__cpp_user_defined_literals) && _MSC_VER >= 1900
# define __cpp_user_defined_literals 190000
#endif

#if !defined(__cpp_variadic_templates) && _MSC_VER >= 1800
# define __cpp_variadic_templates 190000
#endif

// C++ 14
//#if !defined(__cpp_binary_literals) && _MSC_VER >= 1900
//# define __cpp_binary_literals 190000
//#endif

#if !defined(__cpp_contextual_conversions) && _MSC_VER >= 1800
# define __cpp_contextual_conversions 190000
#endif

#if !defined(__cpp_decltype_auto) && _MSC_VER >= 1900
# define __cpp_decltype_auto 190000
#endif

#if !defined(__cpp_aggregate_nsdmi) && _MSC_VER >= 1800
# define __cpp_aggregate_nsdmi 190000
#endif

#if !defined(__cpp_digit_separators) && _MSC_VER >= 1900
# define __cpp_digit_separators 190000
#endif

#if !defined(__cpp_init_captures) && _MSC_VER >= 1900
# define __cpp_init_captures 190000
#endif

#if !defined(__cpp_generic_lambdas) && _MSC_VER >= 1900
# define __cpp_generic_lambdas 190000
#endif

//#if !defined(__cpp_relaxed_constexpr)
//# define __cpp_relaxed_constexpr 190000
//#endif

#if !defined(__cpp_return_type_deduction) && _MSC_VER >= 1900
# define __cpp_return_type_deduction 190000
#endif

//#if !defined(__cpp_runtime_arrays)
//# define __cpp_runtime_arrays 190000
//#endif

//#if !defined(__cpp_variable_templates)
//# define __cpp_variable_templates 190000
//#endif

#endif // _MSC_VER

// Much to my surprise, GCC's support of these is actually incomplete, so fill in the gaps
#if (defined(__GNUC__) && !defined(__clang__))

#define BOOST_BINDLIB_GCC (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)

#if !defined(__cpp_exceptions) && defined(__EXCEPTIONS)
# define __cpp_exceptions 190000
#endif

#if !defined(__cpp_rtti) && defined(__GXX_RTTI)
# define __cpp_rtti 190000
#endif

// C++ 11
#if defined(__GXX_EXPERIMENTAL_CXX0X__)

#if !defined(__cpp_access_control_sfinae) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_access_control_sfinae 190000
#endif

#if !defined(__cpp_alias_templates) && (BOOST_BINDLIB_GCC >= 40700)
# define __cpp_alias_templates 190000
#endif

#if !defined(__cpp_alignas) && (BOOST_BINDLIB_GCC >= 40800)
# define __cpp_alignas 190000
#endif

#if !defined(__cpp_attributes) && (BOOST_BINDLIB_GCC >= 40800)
# define __cpp_attributes 190000
#endif

#if !defined(__cpp_constexpr) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_constexpr 190000
#endif

#if !defined(__cpp_decltype) && (BOOST_BINDLIB_GCC >= 40300)
# define __cpp_decltype 190000
#endif

#if !defined(__cpp_default_function_template_args) && (BOOST_BINDLIB_GCC >= 40300)
# define __cpp_default_function_template_args 190000
#endif

#if !defined(__cpp_defaulted_functions) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_defaulted_functions 190000
#endif

#if !defined(__cpp_delegating_constructors) && (BOOST_BINDLIB_GCC >= 40700)
# define __cpp_delegating_constructors 190000
#endif

#if !defined(__cpp_deleted_functions) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_deleted_functions 190000
#endif

#if !defined(__cpp_explicit_conversions) && (BOOST_BINDLIB_GCC >= 40500)
# define __cpp_explicit_conversions 190000
#endif

#if !defined(__cpp_generalized_initializers) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_generalized_initializers 190000
#endif

#if !defined(__cpp_implicit_moves) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_implicit_moves 190000
#endif

#if !defined(__cpp_inheriting_constructors) && (BOOST_BINDLIB_GCC >= 40800)
# define __cpp_inheriting_constructors 190000
#endif

#if !defined(__cpp_inline_namespaces) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_inline_namespaces 190000
#endif

#if !defined(__cpp_lambdas) && (BOOST_BINDLIB_GCC >= 40500)
# define __cpp_lambdas 190000
#endif

#if !defined(__cpp_local_type_template_args) && (BOOST_BINDLIB_GCC >= 40500)
# define __cpp_local_type_template_args 190000
#endif

#if !defined(__cpp_noexcept) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_noexcept 190000
#endif

#if !defined(__cpp_nonstatic_member_init) && (BOOST_BINDLIB_GCC >= 40700)
# define __cpp_nonstatic_member_init 190000
#endif

#if !defined(__cpp_nullptr) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_nullptr 190000
#endif

#if !defined(__cpp_override_control) && (BOOST_BINDLIB_GCC >= 40700)
# define __cpp_override_control 190000
#endif

#if !defined(__cpp_reference_qualified_functions) && (BOOST_BINDLIB_GCC >= 40801)
# define __cpp_reference_qualified_functions 190000
#endif

#if !defined(__cpp_range_for) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_range_for 190000
#endif

#if !defined(__cpp_raw_strings) && (BOOST_BINDLIB_GCC >= 40500)
# define __cpp_raw_strings 190000
#endif

// __cpp_rvalue_reference deviation
#if !defined(__cpp_rvalue_references) && defined(__cpp_rvalue_reference)
# define __cpp_rvalue_references __cpp_rvalue_reference
#endif

#if !defined(__cpp_static_assert) && (BOOST_BINDLIB_GCC >= 40300)
# define __cpp_static_assert 190000
#endif

#if !defined(__cpp_thread_local) && (BOOST_BINDLIB_GCC >= 40800)
# define __cpp_thread_local 190000
#endif

#if !defined(__cpp_auto_type) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_auto_type 190000
#endif

#if !defined(__cpp_strong_enums) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_strong_enums 190000
#endif

#if !defined(__cpp_trailing_return) && (BOOST_BINDLIB_GCC >= 40500)
# define __cpp_trailing_return 190000
#endif

#if !defined(__cpp_unicode_literals) && (BOOST_BINDLIB_GCC >= 40500)
# define __cpp_unicode_literals 190000
#endif

#if !defined(__cpp_unrestricted_unions) && (BOOST_BINDLIB_GCC >= 40600)
# define __cpp_unrestricted_unions 190000
#endif

#if !defined(__cpp_user_defined_literals) && (BOOST_BINDLIB_GCC >= 40700)
# define __cpp_user_defined_literals 190000
#endif

#if !defined(__cpp_variadic_templates) && (BOOST_BINDLIB_GCC >= 40400)
# define __cpp_variadic_templates 190000
#endif

// C++ 14
////#if !defined(__cpp_binary_literals)
////# define __cpp_binary_literals 190000
////#endif

// Strangely missing!
#if !defined(__cpp_contextual_conversions) && (BOOST_BINDLIB_GCC >= 40900)
# define __cpp_contextual_conversions 190000
#endif

////#if !defined(__cpp_decltype_auto)
////# define __cpp_decltype_auto 190000
////#endif

//#if !defined(__cpp_aggregate_nsdmi)
//# define __cpp_aggregate_nsdmi 190000
//#endif

////#if !defined(__cpp_digit_separators)
////# define __cpp_digit_separators 190000
////#endif

////#if !defined(__cpp_init_captures)
////# define __cpp_init_captures 190000
////#endif

////#if !defined(__cpp_generic_lambdas)
////# define __cpp_generic_lambdas 190000
////#endif

//#if !defined(__cpp_relaxed_constexpr)
//# define __cpp_relaxed_constexpr 190000
//#endif

//#if !defined(__cpp_return_type_deduction)
//# define __cpp_return_type_deduction 190000
//#endif

////#if !defined(__cpp_runtime_arrays)
////# define __cpp_runtime_arrays 190000
////#endif

//#if !defined(__cpp_variable_templates)
//# define __cpp_variable_templates 190000
//#endif

#endif // __GXX_EXPERIMENTAL_CXX0X__

#endif // GCC

// clang deviates in some places from the present SG-10 draft, plus older
// clangs are quite incomplete
#if defined(__clang__)

#define BOOST_BINDLIB_CLANG (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__)

#if !defined(__cpp_exceptions) && defined(__EXCEPTIONS)
# define __cpp_exceptions 190000
#endif

#if !defined(__cpp_rtti) && defined(__GXX_RTTI)
# define __cpp_rtti 190000
#endif

// C++ 11
#if defined(__GXX_EXPERIMENTAL_CXX0X__)

#if !defined(__cpp_access_control_sfinae) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_access_control_sfinae 190000
#endif

#if !defined(__cpp_alias_templates) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_alias_templates 190000
#endif

#if !defined(__cpp_alignas) && (BOOST_BINDLIB_CLANG >= 30300)
# define __cpp_alignas 190000
#endif

#if !defined(__cpp_attributes) && (BOOST_BINDLIB_CLANG >= 30300)
# define __cpp_attributes 190000
#endif

#if !defined(__cpp_constexpr) && (BOOST_BINDLIB_CLANG >= 30100)
# define __cpp_constexpr 190000
#endif

#if !defined(__cpp_decltype) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_decltype 190000
#endif

#if !defined(__cpp_default_function_template_args) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_default_function_template_args 190000
#endif

#if !defined(__cpp_defaulted_functions) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_defaulted_functions 190000
#endif

#if !defined(__cpp_delegating_constructors) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_delegating_constructors 190000
#endif

#if !defined(__cpp_deleted_functions) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_deleted_functions 190000
#endif

#if !defined(__cpp_explicit_conversions) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_explicit_conversions 190000
#endif

#if !defined(__cpp_generalized_initializers) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_generalized_initializers 190000
#endif

#if !defined(__cpp_implicit_moves) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_implicit_moves 190000
#endif

#if !defined(__cpp_inheriting_constructors) && (BOOST_BINDLIB_CLANG >= 30300)
# define __cpp_inheriting_constructors 190000
#endif

#if !defined(__cpp_inline_namespaces) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_inline_namespaces 190000
#endif

#if !defined(__cpp_lambdas) && (BOOST_BINDLIB_CLANG >= 30100)
# define __cpp_lambdas 190000
#endif

#if !defined(__cpp_local_type_template_args) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_local_type_template_args 190000
#endif

#if !defined(__cpp_noexcept) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_noexcept 190000
#endif

#if !defined(__cpp_nonstatic_member_init) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_nonstatic_member_init 190000
#endif

#if !defined(__cpp_nullptr) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_nullptr 190000
#endif

#if !defined(__cpp_override_control) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_override_control 190000
#endif

#if !defined(__cpp_reference_qualified_functions) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_reference_qualified_functions 190000
#endif

#if !defined(__cpp_range_for) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_range_for 190000
#endif

// __cpp_raw_string_literals deviation
#if !defined(__cpp_raw_strings) && defined(__cpp_raw_string_literals)
# define __cpp_raw_strings __cpp_raw_string_literals
#endif
#if !defined(__cpp_raw_strings) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_raw_strings 190000
#endif

// __cpp_rvalue_reference deviation
#if !defined(__cpp_rvalue_references) && defined(__cpp_rvalue_reference)
# define __cpp_rvalue_references __cpp_rvalue_reference
#endif
#if !defined(__cpp_rvalue_references) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_rvalue_references 190000
#endif

#if !defined(__cpp_static_assert) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_static_assert 190000
#endif

#if !defined(__cpp_thread_local) && (BOOST_BINDLIB_CLANG >= 30300)
# define __cpp_thread_local 190000
#endif

#if !defined(__cpp_auto_type) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_auto_type 190000
#endif

#if !defined(__cpp_strong_enums) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_strong_enums 190000
#endif

#if !defined(__cpp_trailing_return) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_trailing_return 190000
#endif

#if !defined(__cpp_unicode_literals) && (BOOST_BINDLIB_CLANG >= 30000)
# define __cpp_unicode_literals 190000
#endif

#if !defined(__cpp_unrestricted_unions) && (BOOST_BINDLIB_CLANG >= 30100)
# define __cpp_unrestricted_unions 190000
#endif

// __cpp_user_literals deviation
#if !defined(__cpp_user_defined_literals) && defined(__cpp_user_literals)
# define __cpp_user_defined_literals __cpp_user_literals
#endif
#if !defined(__cpp_user_defined_literals) && (BOOST_BINDLIB_CLANG >= 30100)
# define __cpp_user_defined_literals 190000
#endif

#if !defined(__cpp_variadic_templates) && (BOOST_BINDLIB_CLANG >= 20900)
# define __cpp_variadic_templates 190000
#endif

// C++ 14
////#if !defined(__cpp_binary_literals)
////# define __cpp_binary_literals 190000
////#endif

////#if !defined(__cpp_contextual_conversions)
////# define __cpp_contextual_conversions 190000
////#endif

////#if !defined(__cpp_decltype_auto)
////# define __cpp_decltype_auto 190000
////#endif

////#if !defined(__cpp_aggregate_nsdmi)
////# define __cpp_aggregate_nsdmi 190000
////#endif

////#if !defined(__cpp_digit_separators)
////# define __cpp_digit_separators 190000
////#endif

////#if !defined(__cpp_init_captures)
////# define __cpp_init_captures 190000
////#endif

////#if !defined(__cpp_generic_lambdas)
////# define __cpp_generic_lambdas 190000
////#endif

////#if !defined(__cpp_relaxed_constexpr)
////# define __cpp_relaxed_constexpr 190000
////#endif

////#if !defined(__cpp_return_type_deduction)
////# define __cpp_return_type_deduction 190000
////#endif

// __cpp_runtime_array deviation
#if !defined(__cpp_runtime_arrays) && defined(__cpp_runtime_array)
# define __cpp_runtime_arrays __cpp_runtime_array
#endif

////#if !defined(__cpp_variable_templates)
////# define __cpp_variable_templates 190000
////#endif

#endif // __GXX_EXPERIMENTAL_CXX0X__

#endif // clang

#endif
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/boost/../cpp_feature.h */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/boost/config.hpp */


#ifndef BOOST_SMT_PAUSE
# if defined(_MSC_VER) && _MSC_VER >= 1310 && ( defined(_M_IX86) || defined(_M_X64) )
extern "C" void _mm_pause();
#  pragma intrinsic( _mm_pause )
#  define BOOST_SMT_PAUSE _mm_pause();
# elif defined(__GNUC__) && ( defined(__i386__) || defined(__x86_64__) )
#  define BOOST_SMT_PAUSE __asm__ __volatile__( "rep; nop" : : : "memory" );
# endif
#endif

#ifndef BOOST_NOEXCEPT
# ifdef __cpp_noexcept
#  define BOOST_NOEXCEPT noexcept
# endif
#endif
#ifndef BOOST_NOEXCEPT
# define BOOST_NOEXCEPT
#endif

#ifndef BOOST_NOEXCEPT_OR_NOTHROW
# ifdef __cpp_noexcept
#  define BOOST_NOEXCEPT_OR_NOTHROW noexcept
# endif
#endif
#ifndef BOOST_NOEXCEPT_OR_NOTHROW
# define BOOST_NOEXCEPT_OR_NOTHROW throw()
#endif

#ifndef BOOST_NOEXCEPT_IF
# ifdef __cpp_noexcept
#  define BOOST_NOEXCEPT_IF(v) noexcept(v)
# endif
#endif
#ifndef BOOST_NOEXCEPT_IF
# define BOOST_NOEXCEPT_IF(v)
#endif

#ifndef BOOST_NOEXCEPT_EXPR
# ifdef __cpp_noexcept
#  define BOOST_NOEXCEPT_EXPR(v) noexcept(v)
# endif
#endif
#ifndef BOOST_NOEXCEPT_EXPR
# define BOOST_NOEXCEPT_EXPR(v) false
#endif

#ifndef BOOST_CONSTEXPR
# ifdef __cpp_constexpr
#  define BOOST_CONSTEXPR constexpr
# endif
#endif
#ifndef BOOST_CONSTEXPR
# define BOOST_CONSTEXPR
#endif

#ifndef BOOST_CXX14_CONSTEXPR
# ifdef __cpp_relaxed_constexpr
#  define BOOST_CXX14_CONSTEXPR constexpr
# endif
#endif
#ifndef BOOST_CXX14_CONSTEXPR
# define BOOST_CXX14_CONSTEXPR
#endif

#ifndef BOOST_CONSTEXPR_OR_CONST
# ifdef __cpp_constexpr
#  define BOOST_CONSTEXPR_OR_CONST constexpr
# endif
#endif
#ifndef BOOST_CONSTEXPR_OR_CONST
# define BOOST_CONSTEXPR_OR_CONST const
#endif

#ifndef BOOST_STATIC_CONSTEXPR
# ifdef __cpp_constexpr
#  define BOOST_STATIC_CONSTEXPR static constexpr
# endif
#endif
#ifndef BOOST_STATIC_CONSTEXPR
# define BOOST_STATIC_CONSTEXPR static const
#endif

#ifndef BOOST_FORCEINLINE
# if defined(_MSC_VER)
#  define BOOST_FORCEINLINE __forceinline
# elif defined(__GNUC__)
#  define BOOST_FORCEINLINE __attribute__((always_inline))
# else
#  define BOOST_FORCEINLINE
# endif
#endif

#ifndef BOOST_NOINLINE
# if defined(_MSC_VER)
#  define BOOST_NOINLINE __declspec(noinline)
# elif defined(__GNUC__)
#  define BOOST_NOINLINE __attribute__((noinline))
# else
#  define BOOST_NOINLINE
# endif
#endif

#ifndef BOOST_SYMBOL_VISIBLE
# if defined(_MSC_VER)
#  define BOOST_SYMBOL_VISIBLE
# elif defined(__GNUC__)
#  define BOOST_SYMBOL_VISIBLE __attribute__((visibility("default")))
# else
#  define BOOST_SYMBOL_VISIBLE
# endif
#endif

#ifndef BOOST_SYMBOL_EXPORT
# if defined(_MSC_VER)
#  define BOOST_SYMBOL_EXPORT __declspec(dllexport)
# elif defined(__GNUC__)
#  define BOOST_SYMBOL_EXPORT __attribute__((visibility("default")))
# else
#  define BOOST_SYMBOL_EXPORT
# endif
#endif

#ifndef BOOST_SYMBOL_IMPORT
# if defined(_MSC_VER)
#  define BOOST_SYMBOL_IMPORT __declspec(dllimport)
# elif defined(__GNUC__)
#  define BOOST_SYMBOL_IMPORT
# else
#  define BOOST_SYMBOL_IMPORT
# endif
#endif

#ifndef BOOST_FOREACH
#define BOOST_FOREACH(a, b) for(a : b)
#endif

#ifndef BOOST_MSVC
#ifdef _MSC_VER
#define BOOST_MSVC _MSC_VER
#endif
#endif
#ifndef BOOST_WINDOWS
#ifdef WIN32
#define BOOST_WINDOWS 1
#endif
#endif
#ifndef BOOST_GCC
#ifdef __GNUC__
#define BOOST_GCC (__GNUC__ * 10000 \
+ __GNUC_MINOR__ * 100 \
+ __GNUC_PATCHLEVEL__)
#endif
#endif

/* The following are for convenience, but really should be regex find & replace in modern C++ */
#ifndef BOOST_FWD_REF
#define BOOST_FWD_REF(a) a&&
#endif

#ifndef BOOST_RV_REF
#define BOOST_RV_REF(a) a&&
#endif

#ifndef BOOST_COPY_ASSIGN_REF
#define BOOST_COPY_ASSIGN_REF(a) const a&
#endif

#ifndef BOOST_STATIC_ASSERT_MSG
#define BOOST_STATIC_ASSERT_MSG(v, m) static_assert((v), m)
#endif

// Map SG10 feature macros to Boost ones
#if !defined(__cpp_exceptions) && !defined(BOOST_NO_EXCEPTIONS)
# define BOOST_NO_EXCEPTIONS 1
#endif

#if !defined(__cpp_rtti) && !defined(BOOST_NO_RTTI)
# define BOOST_NO_RTTI 1
#endif

// C++ 11
//#if !defined(__cpp_access_control_sfinae)
//# define __cpp_access_control_sfinae 190000
//#endif

#if !defined(__cpp_alias_templates) && !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)
# define BOOST_NO_CXX11_TEMPLATE_ALIASES 1
#endif

#if !defined(__cpp_alignas) && !defined(BOOST_NO_CXX11_ALIGNAS)
# define BOOST_NO_CXX11_ALIGNAS 1
#endif

//#if !defined(__cpp_attributes)
//# define __cpp_attributes 190000
//#endif

#if !defined(__cpp_constexpr) && !defined(BOOST_NO_CXX11_CONSTEXPR)
# define BOOST_NO_CXX11_CONSTEXPR 1
#endif

#if !defined(__cpp_decltype) && !defined(BOOST_NO_CXX11_DECLTYPE)
# define BOOST_NO_CXX11_DECLTYPE 1
#endif

#if !defined(__cpp_default_function_template_args) && !defined(BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS)
# define BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS 1
#endif

#if !defined(__cpp_defaulted_functions) && !defined(BOOST_NO_CXX11_DEFAULTED_FUNCTIONS)
# define BOOST_NO_CXX11_DEFAULTED_FUNCTIONS 1
#endif

//#if !defined(__cpp_delegating_constructors)
//# define __cpp_delegating_constructors 190000
//#endif

#if !defined(__cpp_deleted_functions) && !defined(BOOST_NO_CXX11_DELETED_FUNCTIONS)
# define BOOST_NO_CXX11_DELETED_FUNCTIONS 1
#endif

#if !defined(__cpp_explicit_conversions) && !defined(BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS)
# define BOOST_NO_CXX11_EXPLICIT_CONVERSION_OPERATORS 1
#endif

#if !defined(__cpp_generalized_initializers) && !defined(BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX)
# define BOOST_NO_CXX11_UNIFIED_INITIALIZATION_SYNTAX 1
#endif

//#if !defined(__cpp_implicit_moves)
//# define __cpp_implicit_moves 190000
//#endif

//#if !defined(__cpp_inheriting_constructors)
//# define __cpp_inheriting_constructors 190000
//#endif

#if !defined(__cpp_inline_namespaces) && !defined(BOOST_NO_CXX11_INLINE_NAMESPACES)
# define BOOST_NO_CXX11_INLINE_NAMESPACES 1
#endif

#if !defined(__cpp_lambdas) && !defined(BOOST_NO_CXX11_LAMBDAS)
# define BOOST_NO_CXX11_LAMBDAS 1
#endif

//#if !defined(__cpp_local_type_template_args)
//# define __cpp_local_type_template_args 190000
//#endif

#if !defined(__cpp_noexcept) && !defined(BOOST_NO_CXX11_NOEXCEPT)
# define BOOST_NO_CXX11_NOEXCEPT 1
#endif

//#if !defined(__cpp_nonstatic_member_init)
//# define __cpp_nonstatic_member_init 190000
//#endif

#if !defined(__cpp_nullptr) && !defined(BOOST_NO_CXX11_NULLPTR)
# define BOOST_NO_CXX11_NULLPTR 1
#endif

//#if !defined(__cpp_override_control)
//# define __cpp_override_control 190000
//#endif

#if !defined(__cpp_reference_qualified_functions) && !defined(BOOST_NO_CXX11_REF_QUALIFIERS)
# define BOOST_NO_CXX11_REF_QUALIFIERS 1
#endif

#if !defined(__cpp_range_for) && !defined(BOOST_NO_CXX11_RANGE_BASED_FOR)
# define BOOST_NO_CXX11_RANGE_BASED_FOR 1
#endif

#if !defined(__cpp_raw_strings) && !defined(BOOST_NO_CXX11_RAW_LITERALS)
# define BOOST_NO_CXX11_RAW_LITERALS 1
#endif

#if !defined(__cpp_rvalue_references) && !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
# define BOOST_NO_CXX11_RVALUE_REFERENCES 1
#endif

#if !defined(__cpp_static_assert) && !defined(BOOST_NO_CXX11_STATIC_ASSERT)
# define BOOST_NO_CXX11_STATIC_ASSERT 1
#endif

//#if !defined(__cpp_thread_local)
//# define __cpp_thread_local 190000
//#endif

#if !defined(__cpp_auto_type) && !defined(BOOST_NO_CXX11_AUTO_DECLARATIONS)
# define BOOST_NO_CXX11_AUTO_DECLARATIONS 1
# define BOOST_NO_CXX11_AUTO_MULTIDECLARATIONS 1
#endif

#if !defined(__cpp_strong_enums) && !defined(BOOST_NO_CXX11_SCOPED_ENUMS)
# define BOOST_NO_CXX11_SCOPED_ENUMS 1
#endif

#if !defined(__cpp_trailing_return) && !defined(BOOST_NO_CXX11_TRAILING_RESULT_TYPES)
# define BOOST_NO_CXX11_TRAILING_RESULT_TYPES 1
#endif

#if !defined(__cpp_unicode_literals) && !defined(BOOST_NO_CXX11_UNICODE_LITERALS)
# define BOOST_NO_CXX11_UNICODE_LITERALS 1
#endif

//#if !defined(__cpp_unrestricted_unions)
//# define __cpp_unrestricted_unions 190000
//#endif

#if !defined(__cpp_user_defined_literals) && !defined(BOOST_NO_CXX11_USER_DEFINED_LITERALS)
# define BOOST_NO_CXX11_USER_DEFINED_LITERALS 1
#endif

#if !defined(__cpp_variadic_templates) && !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES)
# define BOOST_NO_CXX11_VARIADIC_TEMPLATES 1
#endif

// C++ 14
#if !defined(__cpp_binary_literals) && !defined(BOOST_NO_CXX14_BINARY_LITERALS)
# define BOOST_NO_CXX14_BINARY_LITERALS 1
#endif

//#if !defined(__cpp_contextual_conversions)
//# define __cpp_contextual_conversions 190000
//#endif

#if !defined(__cpp_decltype_auto) && !defined(BOOST_NO_CXX14_DECLTYPE_AUTO)
# define BOOST_NO_CXX14_DECLTYPE_AUTO 1
#endif

#if !defined(__cpp_aggregate_nsdmi) && !defined(BOOST_NO_CXX14_AGGREGATE_NSDMI)
# define BOOST_NO_CXX14_AGGREGATE_NSDMI 1
#endif

#if !defined(__cpp_digit_separators) && !defined(BOOST_NO_CXX14_DIGIT_SEPARATORS)
# define BOOST_NO_CXX14_DIGIT_SEPARATORS 1
#endif

#if !defined(__cpp_init_captures) && !defined(BOOST_NO_CXX14_INITIALIZED_LAMBDA_CAPTURES)
# define BOOST_NO_CXX14_INITIALIZED_LAMBDA_CAPTURES 1
#endif

#if !defined(__cpp_generic_lambdas) && !defined(BOOST_NO_CXX14_GENERIC_LAMBDAS)
# define BOOST_NO_CXX14_GENERIC_LAMBDAS 1
#endif

#if !defined(__cpp_relaxed_constexpr) && !defined(BOOST_NO_CXX14_CONSTEXPR)
# define BOOST_NO_CXX14_CONSTEXPR 1
#endif

#if !defined(__cpp_return_type_deduction) && !defined(BOOST_NO_CXX14_RETURN_TYPE_DEDUCTION)
# define BOOST_NO_CXX14_RETURN_TYPE_DEDUCTION 1
#endif

//#if !defined(__cpp_runtime_arrays)
//# define __cpp_runtime_arrays 190000
//#endif

#if !defined(__cpp_variable_templates) && !defined(BOOST_NO_CXX14_VARIABLE_TEMPLATES)
# define BOOST_NO_CXX14_VARIABLE_TEMPLATES 1
#endif

#endif
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/boost/config.hpp */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */

#else
#include "boost/config.hpp"
#endif

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/import.h */
/* import.hpp
Convenience macros for importing local namespace binds
(C) 2014 Niall Douglas http://www.nedprod.com/
File Created: Aug 2014

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_BINDLIB_IMPORT_HPP
#define BOOST_BINDLIB_IMPORT_HPP


#ifndef BOOST_BINDLIB_DISABLE_NAMESPACE_MODIFIERS
# ifndef __cpp_inline_namespaces
#  define BOOST_BINDLIB_DISABLE_NAMESPACE_MODIFIERS
# endif
#endif

/* 2014-10-9 ned: I lost today figuring out the below. I really hate the C preprocessor now.
*
* Anyway, infinity = 8. It's easy to expand below if needed.
*/
/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/detail/preprocessor_macro_overload.h */
/* preprocessor_macro_overload.h
MSVC capable preprocessor macro overloading
(C) 2014 Niall Douglas http://www.nedprod.com/
File Created: Aug 2014

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef BOOST_BINDLIB_PREPROCESSOR_MACRO_OVERLOAD_H
#define BOOST_BINDLIB_PREPROCESSOR_MACRO_OVERLOAD_H

#define BOOST_BINDLIB_GLUE(x, y) x y

#define BOOST_BINDLIB_RETURN_ARG_COUNT(_1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, count, ...) count
#define BOOST_BINDLIB_EXPAND_ARGS(args) BOOST_BINDLIB_RETURN_ARG_COUNT args
#define BOOST_BINDLIB_COUNT_ARGS_MAX8(...) BOOST_BINDLIB_EXPAND_ARGS((__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1, 0))

#define BOOST_BINDLIB_OVERLOAD_MACRO2(name, count) name##count
#define BOOST_BINDLIB_OVERLOAD_MACRO1(name, count) BOOST_BINDLIB_OVERLOAD_MACRO2(name, count)
#define BOOST_BINDLIB_OVERLOAD_MACRO(name, count) BOOST_BINDLIB_OVERLOAD_MACRO1(name, count)

#define BOOST_BINDLIB_CALL_OVERLOAD(name, ...) BOOST_BINDLIB_GLUE(BOOST_BINDLIB_OVERLOAD_MACRO(name, BOOST_BINDLIB_COUNT_ARGS_MAX8(__VA_ARGS__)), (__VA_ARGS__))

#define BOOST_BINDLIB_GLUE_(x, y) x y

#define BOOST_BINDLIB_RETURN_ARG_COUNT_(_1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, count, ...) count
#define BOOST_BINDLIB_EXPAND_ARGS_(args) BOOST_BINDLIB_RETURN_ARG_COUNT_ args
#define BOOST_BINDLIB_COUNT_ARGS_MAX8_(...) BOOST_BINDLIB_EXPAND_ARGS_((__VA_ARGS__, 8, 7, 6, 5, 4, 3, 2, 1, 0))

#define BOOST_BINDLIB_OVERLOAD_MACRO2_(name, count) name##count
#define BOOST_BINDLIB_OVERLOAD_MACRO1_(name, count) BOOST_BINDLIB_OVERLOAD_MACRO2_(name, count)
#define BOOST_BINDLIB_OVERLOAD_MACRO_(name, count) BOOST_BINDLIB_OVERLOAD_MACRO1_(name, count)

#define BOOST_BINDLIB_CALL_OVERLOAD_(name, ...) BOOST_BINDLIB_GLUE_(BOOST_BINDLIB_OVERLOAD_MACRO_(name, BOOST_BINDLIB_COUNT_ARGS_MAX8_(__VA_ARGS__)), (__VA_ARGS__))

#endif
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/detail/preprocessor_macro_overload.h */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/import.h */


#define BOOST_BINDLIB_STRINGIZE(a) #a
#define BOOST_BINDLIB_STRINGIZE2(a) BOOST_BINDLIB_STRINGIZE(a)
#define BOOST_BINDLIB_NAMESPACE_VERSION8(a, b, c, d, e, f, g, h) a ## _ ## b ## _ ## c ## _ ## d ## _ ## e ## _ ## f ## _ ## g ## _ ## h
#define BOOST_BINDLIB_NAMESPACE_VERSION7(a, b, c, d, e, f, g) a ## _ ## b ## _ ## c ## _ ## d ## _ ## e ## _ ## f ## _ ## g
#define BOOST_BINDLIB_NAMESPACE_VERSION6(a, b, c, d, e, f) a ## _ ## b ## _ ## c ## _ ## d ## _ ## e ## _ ## f
#define BOOST_BINDLIB_NAMESPACE_VERSION5(a, b, c, d, e) a ## _ ## b ## _ ## c ## _ ## d ## _ ## e
#define BOOST_BINDLIB_NAMESPACE_VERSION4(a, b, c, d) a ## _ ## b ## _ ## c ## _ ## d
#define BOOST_BINDLIB_NAMESPACE_VERSION3(a, b, c) a ## _ ## b ## _ ## c
#define BOOST_BINDLIB_NAMESPACE_VERSION2(a, b) a ## _ ## b
#define BOOST_BINDLIB_NAMESPACE_VERSION1(a) a
//! Concatenates each parameter with _
#define BOOST_BINDLIB_NAMESPACE_VERSION(...) BOOST_BINDLIB_CALL_OVERLOAD(BOOST_BINDLIB_NAMESPACE_VERSION,__VA_ARGS__)

#ifdef BOOST_BINDLIB_DISABLE_NAMESPACE_MODIFIERS
# define BOOST_BINDLIB_NAMESPACE_SELECT_2(name, modifier)
# define BOOST_BINDLIB_NAMESPACE_SELECT2(name, modifier)
#else
# define BOOST_BINDLIB_NAMESPACE_SELECT_2(name, modifier) name
# define BOOST_BINDLIB_NAMESPACE_SELECT2(name, modifier) :: name
#endif
#define BOOST_BINDLIB_NAMESPACE_SELECT_1(name) name
#define BOOST_BINDLIB_NAMESPACE_SELECT1(name) :: name
#define BOOST_BINDLIB_NAMESPACE_SELECT_(...) BOOST_BINDLIB_CALL_OVERLOAD_(BOOST_BINDLIB_NAMESPACE_SELECT_,__VA_ARGS__)
#define BOOST_BINDLIB_NAMESPACE_SELECT(...) BOOST_BINDLIB_CALL_OVERLOAD_(BOOST_BINDLIB_NAMESPACE_SELECT,__VA_ARGS__)
#define BOOST_BINDLIB_NAMESPACE_EXPAND8(a, b, c, d, e, f, g, h) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b BOOST_BINDLIB_NAMESPACE_SELECT c BOOST_BINDLIB_NAMESPACE_SELECT d BOOST_BINDLIB_NAMESPACE_SELECT e BOOST_BINDLIB_NAMESPACE_SELECT f BOOST_BINDLIB_NAMESPACE_SELECT g BOOST_BINDLIB_NAMESPACE_SELECT h
#define BOOST_BINDLIB_NAMESPACE_EXPAND7(a, b, c, d, e, f, g) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b BOOST_BINDLIB_NAMESPACE_SELECT c BOOST_BINDLIB_NAMESPACE_SELECT d BOOST_BINDLIB_NAMESPACE_SELECT e BOOST_BINDLIB_NAMESPACE_SELECT f BOOST_BINDLIB_NAMESPACE_SELECT g
#define BOOST_BINDLIB_NAMESPACE_EXPAND6(a, b, c, d, e, f) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b BOOST_BINDLIB_NAMESPACE_SELECT c BOOST_BINDLIB_NAMESPACE_SELECT d BOOST_BINDLIB_NAMESPACE_SELECT e BOOST_BINDLIB_NAMESPACE_SELECT f
#define BOOST_BINDLIB_NAMESPACE_EXPAND5(a, b, c, d, e) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b BOOST_BINDLIB_NAMESPACE_SELECT c BOOST_BINDLIB_NAMESPACE_SELECT d BOOST_BINDLIB_NAMESPACE_SELECT e
#define BOOST_BINDLIB_NAMESPACE_EXPAND4(a, b, c, d) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b BOOST_BINDLIB_NAMESPACE_SELECT c BOOST_BINDLIB_NAMESPACE_SELECT d
#define BOOST_BINDLIB_NAMESPACE_EXPAND3(a, b, c) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b BOOST_BINDLIB_NAMESPACE_SELECT c
#define BOOST_BINDLIB_NAMESPACE_EXPAND2(a, b) BOOST_BINDLIB_NAMESPACE_SELECT_ a BOOST_BINDLIB_NAMESPACE_SELECT b
#define BOOST_BINDLIB_NAMESPACE_EXPAND1(a) BOOST_BINDLIB_NAMESPACE_SELECT_ a
//! Expands into a::b::c:: ...
#define BOOST_BINDLIB_NAMESPACE(...) BOOST_BINDLIB_CALL_OVERLOAD(BOOST_BINDLIB_NAMESPACE_EXPAND,__VA_ARGS__)

#ifdef BOOST_BINDLIB_DISABLE_NAMESPACE_MODIFIERS
# define BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT2(name, modifier)
#else
# define BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT2(name, modifier) modifier namespace name {
#endif
#define BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT1(name) namespace name {
#define BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT(...) BOOST_BINDLIB_CALL_OVERLOAD_(BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT,__VA_ARGS__)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND8(a, b, c, d, e, f, g, h) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND7(b, c, d, e, f, g, h)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND7(a, b, c, d, e, f, g) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND6(b, c, d, e, f, g)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND6(a, b, c, d, e, f) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND5(b, c, d, e, f)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND5(a, b, c, d, e) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND4(b, c, d, e)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND4(a, b, c, d) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND3(b, c, d)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND3(a, b, c) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND2(b, c)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND2(a, b) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND1(b)
#define BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND1(a) BOOST_BINDLIB_NAMESPACE_BEGIN_NAMESPACE_SELECT a

//! Expands into namespace a { namespace b { namespace c ...
#define BOOST_BINDLIB_NAMESPACE_BEGIN(...) BOOST_BINDLIB_CALL_OVERLOAD(BOOST_BINDLIB_NAMESPACE_BEGIN_EXPAND,__VA_ARGS__)

#ifdef BOOST_BINDLIB_DISABLE_NAMESPACE_MODIFIERS
# define BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT2(name, modifier)
#else
# define BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT2(name, modifier) }
#endif
#define BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT1(name) }
#define BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT(...) BOOST_BINDLIB_CALL_OVERLOAD_(BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT,__VA_ARGS__)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND8(a, b, c, d, e, f, g, h) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND7(b, c, d, e, f, g, h)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND7(a, b, c, d, e, f, g) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND6(b, c, d, e, f, g)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND6(a, b, c, d, e, f) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND5(b, c, d, e, f)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND5(a, b, c, d, e) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND4(b, c, d, e)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND4(a, b, c, d) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND3(b, c, d)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND3(a, b, c) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND2(b, c)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND2(a, b) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a BOOST_BINDLIB_NAMESPACE_END_EXPAND1(b)
#define BOOST_BINDLIB_NAMESPACE_END_EXPAND1(a) BOOST_BINDLIB_NAMESPACE_END_NAMESPACE_SELECT a

//! Expands into } } ...
#define BOOST_BINDLIB_NAMESPACE_END(...) BOOST_BINDLIB_CALL_OVERLOAD(BOOST_BINDLIB_NAMESPACE_END_EXPAND,__VA_ARGS__)

//! Expands into "local-bind-cpp-library/bind/stl11/impl/library"
#define BOOST_BINDLIB_INCLUDE_STL11(prefix, impl, lib) BOOST_BINDLIB_STRINGIZE(prefix/bind/stl11/impl/lib)
#define BOOST_BINDLIB_INCLUDE_STL1z(prefix, impl, lib) BOOST_BINDLIB_STRINGIZE(prefix/bind/stl1z/impl/lib)

//! Expands into a static const char string array used to mark BindLib compatible namespaces
#define BOOST_BINDLIB_DECLARE(decl, desc) static const char *boost_bindlib_out[]={ #decl, desc };

#ifdef _MSC_VER
# define BOOST_BINDLIB_MESSAGE_PRAGMA2(x) __pragma(message(x))
# define BOOST_BINDLIB_MESSAGE_PRAGMA(x) BOOST_BINDLIB_MESSAGE_PRAGMA2(x)
# define BOOST_BINDLIB_MESSAGE_PREFIX(type) __FILE__ "(" BOOST_BINDLIB_STRINGIZE2(__LINE__) "): " type ": "
# define BOOST_BINDLIB_MESSAGE_(type, prefix, msg) BOOST_BINDLIB_MESSAGE_PRAGMA(prefix msg)
#else
# define BOOST_BINDLIB_MESSAGE_PRAGMA2(x) _Pragma(#x)
# define BOOST_BINDLIB_MESSAGE_PRAGMA(type, x) BOOST_BINDLIB_MESSAGE_PRAGMA2(type x)
# define BOOST_BINDLIB_MESSAGE_(type, prefix, msg) BOOST_BINDLIB_MESSAGE_PRAGMA(type, msg)
#endif
//! Have the compiler output a message
#define BOOST_BINDLIB_MESSAGE(msg) BOOST_BINDLIB_MESSAGE_(message, BOOST_BINDLIB_MESSAGE_PREFIX("message"), msg)
//! Have the compiler output a note
#define BOOST_BINDLIB_NOTE(msg) BOOST_BINDLIB_MESSAGE_(message, BOOST_BINDLIB_MESSAGE_PREFIX("note"), msg)
//! Have the compiler output a warning
#define BOOST_BINDLIB_WARNING(msg) BOOST_BINDLIB_MESSAGE_(GCC warning, BOOST_BINDLIB_MESSAGE_PREFIX("warning"), msg)
//! Have the compiler output an error
#define BOOST_BINDLIB_ERROR(msg) BOOST_BINDLIB_MESSAGE_(GCC error, BOOST_BINDLIB_MESSAGE_PREFIX("error"), msg)

#if defined(BOOST_BINDLIB_DISABLE_NAMESPACE_MODIFIERS) && !defined(BOOST_BINDLIB_SUPPRESS_WARNINGS)
BOOST_BINDLIB_WARNING("Boost.BindLib: inline namespace support not available or disabled, therefore ABI versioning inhibited")
#endif

#endif
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/include/import.h */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */


#if ! defined BOOST_SPINLOCK_CONSTEXPR
# ifdef __cpp_constexpr
// clang 3.2 and earlier has buggy constexpr support
#  if !defined(__clang__) || (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) >= 30300
#   define BOOST_SPINLOCK_CONSTEXPR constexpr
#  endif
# endif
#endif
#ifndef BOOST_SPINLOCK_CONSTEXPR
# define BOOST_SPINLOCK_CONSTEXPR
#endif

#if ! defined BOOST_SPINLOCK_RELAXED_CONSTEXPR
# ifdef __cpp_relaxed_constexpr
#  define BOOST_SPINLOCK_RELAXED_CONSTEXPR constexpr
# endif
#endif
#ifndef BOOST_SPINLOCK_RELAXED_CONSTEXPR
# define BOOST_SPINLOCK_RELAXED_CONSTEXPR
#endif

#if !defined BOOST_SPINLOCK_NOINLINE
# define BOOST_SPINLOCK_NOINLINE BOOST_NOINLINE
#endif

#if !defined BOOST_SPINLOCK_FORCEINLINE
# define BOOST_SPINLOCK_FORCEINLINE BOOST_FORCEINLINE
#endif

#ifndef BOOST_SPINLOCK_IN_THREAD_SANITIZER
# if defined(__has_feature)
#  if __has_feature(thread_sanitizer)
#   define BOOST_SPINLOCK_IN_THREAD_SANITIZER 1
#  endif
# elif defined(__SANITIZE_ADDRESS__)
#  define BOOST_SPINLOCK_IN_THREAD_SANITIZER 1
# endif
#endif
#ifndef BOOST_SPINLOCK_IN_THREAD_SANITIZER
# define BOOST_SPINLOCK_IN_THREAD_SANITIZER 0
#endif

#ifndef BOOST_SPINLOCK_V1_STL11_IMPL
#define BOOST_SPINLOCK_V1_STL11_IMPL std
#endif
#define BOOST_SPINLOCK_V1 (boost), (spinlock), (BOOST_BINDLIB_NAMESPACE_VERSION(v1, BOOST_SPINLOCK_V1_STL11_IMPL), inline)
#define BOOST_SPINLOCK_V1_NAMESPACE       BOOST_BINDLIB_NAMESPACE      (BOOST_SPINLOCK_V1)
#define BOOST_SPINLOCK_V1_NAMESPACE_BEGIN BOOST_BINDLIB_NAMESPACE_BEGIN(BOOST_SPINLOCK_V1)
#define BOOST_SPINLOCK_V1_NAMESPACE_END   BOOST_BINDLIB_NAMESPACE_END  (BOOST_SPINLOCK_V1)

#define BOOST_STL11_ATOMIC_MAP_NAMESPACE_BEGIN        BOOST_BINDLIB_NAMESPACE_BEGIN(BOOST_SPINLOCK_V1, (stl11, inline))
#define BOOST_STL11_ATOMIC_MAP_NAMESPACE_END          BOOST_BINDLIB_NAMESPACE_END  (BOOST_SPINLOCK_V1, (stl11, inline))
#define BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR32_T // missing VS14
#define BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR16_T // missing VS14
#define BOOST_STL11_CHRONO_MAP_NAMESPACE_BEGIN        BOOST_BINDLIB_NAMESPACE_BEGIN(BOOST_SPINLOCK_V1, (stl11, inline), (chrono))
#define BOOST_STL11_CHRONO_MAP_NAMESPACE_END          BOOST_BINDLIB_NAMESPACE_END  (BOOST_SPINLOCK_V1, (stl11, inline), (chrono))
#define BOOST_STL11_MUTEX_MAP_NAMESPACE_BEGIN         BOOST_BINDLIB_NAMESPACE_BEGIN(BOOST_SPINLOCK_V1, (stl11, inline))
#define BOOST_STL11_MUTEX_MAP_NAMESPACE_END           BOOST_BINDLIB_NAMESPACE_END  (BOOST_SPINLOCK_V1, (stl11, inline))
#define BOOST_STL11_THREAD_MAP_NAMESPACE_BEGIN        BOOST_BINDLIB_NAMESPACE_BEGIN(BOOST_SPINLOCK_V1, (stl11, inline))
#define BOOST_STL11_THREAD_MAP_NAMESPACE_END          BOOST_BINDLIB_NAMESPACE_END  (BOOST_SPINLOCK_V1, (stl11, inline))
/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/atomic */
/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_ATOMIC_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_ATOMIC_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_ATOMIC_MAP_NAMESPACE_BEGIN and BOOST_STL11_ATOMIC_MAP_NAMESPACE_END to use this header file
#endif
#include <atomic>
BOOST_STL11_ATOMIC_MAP_NAMESPACE_BEGIN
extern const char *boost_bindlib_in;
// begin memory_order
#ifdef BOOST_STL11_ATOMIC_MAP_NO_MEMORY_ORDER
#undef BOOST_STL11_ATOMIC_MAP_NO_MEMORY_ORDER
#else
using ::std::memory_order;
using ::std::memory_order_relaxed;
using ::std::memory_order_consume;
using ::std::memory_order_acquire;
using ::std::memory_order_release;
using ::std::memory_order_acq_rel;
using ::std::memory_order_seq_cst;
#endif
// end memory_order
// begin atomic_int_least8_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST8_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST8_T
#else
using ::std::atomic_int_least8_t;
#endif
// end atomic_int_least8_t
// begin atomic_int_fast64_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST64_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST64_T
#else
using ::std::atomic_int_fast64_t;
#endif
// end atomic_int_fast64_t
// begin atomic_ulong
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_ULONG
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_ULONG
#else
using ::std::atomic_ulong;
#endif
// end atomic_ulong
// begin atomic_ushort
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_USHORT
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_USHORT
#else
using ::std::atomic_ushort;
#endif
// end atomic_ushort
// begin atomic_long
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_LONG
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_LONG
#else
using ::std::atomic_long;
#endif
// end atomic_long
// begin atomic_int
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT
#else
using ::std::atomic_int;
#endif
// end atomic_int
// begin atomic_char
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR
#else
using ::std::atomic_char;
#endif
// end atomic_char
// begin atomic_uintptr_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINTPTR_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINTPTR_T
#else
using ::std::atomic_uintptr_t;
#endif
// end atomic_uintptr_t
// begin atomic_ullong
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_ULLONG
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_ULLONG
#else
using ::std::atomic_ullong;
#endif
// end atomic_ullong
// begin atomic_char32_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR32_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR32_T
#else
using ::std::atomic_char32_t;
#endif
// end atomic_char32_t
// begin atomic_uint_fast8_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST8_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST8_T
#else
using ::std::atomic_uint_fast8_t;
#endif
// end atomic_uint_fast8_t
// begin atomic_llong
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_LLONG
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_LLONG
#else
using ::std::atomic_llong;
#endif
// end atomic_llong
// begin atomic_int_least16_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST16_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST16_T
#else
using ::std::atomic_int_least16_t;
#endif
// end atomic_int_least16_t
// begin atomic_wchar_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_WCHAR_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_WCHAR_T
#else
using ::std::atomic_wchar_t;
#endif
// end atomic_wchar_t
// begin atomic_signal_fence
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SIGNAL_FENCE
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SIGNAL_FENCE
#else
using ::std::atomic_signal_fence;
#endif
// end atomic_signal_fence
// begin atomic_flag
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_FLAG
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_FLAG
#else
using atomic_flag = ::std::atomic_flag;
#endif
// end atomic_flag
// begin atomic_int_fast32_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST32_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST32_T
#else
using ::std::atomic_int_fast32_t;
#endif
// end atomic_int_fast32_t
// begin atomic_short
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SHORT
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SHORT
#else
using ::std::atomic_short;
#endif
// end atomic_short
// begin atomic_char16_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR16_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_CHAR16_T
#else
using ::std::atomic_char16_t;
#endif
// end atomic_char16_t
// begin atomic_uint_least64_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST64_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST64_T
#else
using ::std::atomic_uint_least64_t;
#endif
// end atomic_uint_least64_t
// begin atomic_uint_least8_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST8_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST8_T
#else
using ::std::atomic_uint_least8_t;
#endif
// end atomic_uint_least8_t
// begin atomic_thread_fence
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_THREAD_FENCE
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_THREAD_FENCE
#else
using ::std::atomic_thread_fence;
#endif
// end atomic_thread_fence
// begin atomic_uchar
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UCHAR
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UCHAR
#else
using ::std::atomic_uchar;
#endif
// end atomic_uchar
// begin atomic_int_least32_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST32_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST32_T
#else
using ::std::atomic_int_least32_t;
#endif
// end atomic_int_least32_t
// begin atomic_uint
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT
#else
using ::std::atomic_uint;
#endif
// end atomic_uint
// begin atomic_uint_least32_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST32_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST32_T
#else
using ::std::atomic_uint_least32_t;
#endif
// end atomic_uint_least32_t
// begin atomic_int_least64_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST64_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_LEAST64_T
#else
using ::std::atomic_int_least64_t;
#endif
// end atomic_int_least64_t
// begin atomic_size_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SIZE_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SIZE_T
#else
using ::std::atomic_size_t;
#endif
// end atomic_size_t
// begin atomic_int_fast8_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST8_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST8_T
#else
using ::std::atomic_int_fast8_t;
#endif
// end atomic_int_fast8_t
// begin atomic_int_fast16_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST16_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INT_FAST16_T
#else
using ::std::atomic_int_fast16_t;
#endif
// end atomic_int_fast16_t
// begin atomic_uintmax_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINTMAX_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINTMAX_T
#else
using ::std::atomic_uintmax_t;
#endif
// end atomic_uintmax_t
// begin atomic_uint_fast16_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST16_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST16_T
#else
using ::std::atomic_uint_fast16_t;
#endif
// end atomic_uint_fast16_t
// begin atomic_uint_fast32_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST32_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST32_T
#else
using ::std::atomic_uint_fast32_t;
#endif
// end atomic_uint_fast32_t
// begin atomic_uint_fast64_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST64_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_FAST64_T
#else
using ::std::atomic_uint_fast64_t;
#endif
// end atomic_uint_fast64_t
// begin atomic_schar
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SCHAR
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_SCHAR
#else
using ::std::atomic_schar;
#endif
// end atomic_schar
// begin atomic_intptr_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INTPTR_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INTPTR_T
#else
using ::std::atomic_intptr_t;
#endif
// end atomic_intptr_t
// begin atomic_intmax_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INTMAX_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_INTMAX_T
#else
using ::std::atomic_intmax_t;
#endif
// end atomic_intmax_t
// begin atomic_uint_least16_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST16_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_UINT_LEAST16_T
#else
using ::std::atomic_uint_least16_t;
#endif
// end atomic_uint_least16_t
// begin atomic
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC
#else
template<class _Tp> using atomic = ::std::atomic<_Tp>;
#endif
// end atomic
// begin atomic_ptrdiff_t
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_PTRDIFF_T
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_PTRDIFF_T
#else
using ::std::atomic_ptrdiff_t;
#endif
// end atomic_ptrdiff_t
// begin atomic_bool
#ifdef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_BOOL
#undef BOOST_STL11_ATOMIC_MAP_NO_ATOMIC_BOOL
#else
using atomic_bool = ::std::atomic_bool;
#endif
// end atomic_bool
BOOST_STL11_ATOMIC_MAP_NAMESPACE_END
#undef BOOST_STL11_ATOMIC_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_ATOMIC_MAP_NAMESPACE_END
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/atomic */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/chrono */
/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_CHRONO_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_CHRONO_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_CHRONO_MAP_NAMESPACE_BEGIN and BOOST_STL11_CHRONO_MAP_NAMESPACE_END to use this header file
#endif
#include <chrono>
BOOST_STL11_CHRONO_MAP_NAMESPACE_BEGIN
extern const char *boost_bindlib_in;
// begin time_point_cast
#ifdef BOOST_STL11_CHRONO_MAP_NO_TIME_POINT_CAST
#undef BOOST_STL11_CHRONO_MAP_NO_TIME_POINT_CAST
#else
using ::std::chrono::time_point_cast;
#endif
// end time_point_cast
// begin hours
#ifdef BOOST_STL11_CHRONO_MAP_NO_HOURS
#undef BOOST_STL11_CHRONO_MAP_NO_HOURS
#else
using ::std::chrono::hours;
#endif
// end hours
// begin system_clock
#ifdef BOOST_STL11_CHRONO_MAP_NO_SYSTEM_CLOCK
#undef BOOST_STL11_CHRONO_MAP_NO_SYSTEM_CLOCK
#else
using system_clock = ::std::chrono::system_clock;
#endif
// end system_clock
// begin duration
#ifdef BOOST_STL11_CHRONO_MAP_NO_DURATION
#undef BOOST_STL11_CHRONO_MAP_NO_DURATION
#else
template<class _Rep, class _Period> using duration = ::std::chrono::duration<_Rep, _Period>;
#endif
// end duration
// begin time_point
#ifdef BOOST_STL11_CHRONO_MAP_NO_TIME_POINT
#undef BOOST_STL11_CHRONO_MAP_NO_TIME_POINT
#else
template<class _Clock, class _Dur> using time_point = ::std::chrono::time_point<_Clock, _Dur>;
#endif
// end time_point
// begin duration_cast
#ifdef BOOST_STL11_CHRONO_MAP_NO_DURATION_CAST
#undef BOOST_STL11_CHRONO_MAP_NO_DURATION_CAST
#else
using ::std::chrono::duration_cast;
#endif
// end duration_cast
// begin nanoseconds
#ifdef BOOST_STL11_CHRONO_MAP_NO_NANOSECONDS
#undef BOOST_STL11_CHRONO_MAP_NO_NANOSECONDS
#else
using ::std::chrono::nanoseconds;
#endif
// end nanoseconds
// begin duration_values
#ifdef BOOST_STL11_CHRONO_MAP_NO_DURATION_VALUES
#undef BOOST_STL11_CHRONO_MAP_NO_DURATION_VALUES
#else
template<class _Rep> using duration_values = ::std::chrono::duration_values<_Rep>;
#endif
// end duration_values
// begin microseconds
#ifdef BOOST_STL11_CHRONO_MAP_NO_MICROSECONDS
#undef BOOST_STL11_CHRONO_MAP_NO_MICROSECONDS
#else
using ::std::chrono::microseconds;
#endif
// end microseconds
// begin steady_clock
#ifdef BOOST_STL11_CHRONO_MAP_NO_STEADY_CLOCK
#undef BOOST_STL11_CHRONO_MAP_NO_STEADY_CLOCK
#else
using steady_clock = ::std::chrono::steady_clock;
#endif
// end steady_clock
// begin milliseconds
#ifdef BOOST_STL11_CHRONO_MAP_NO_MILLISECONDS
#undef BOOST_STL11_CHRONO_MAP_NO_MILLISECONDS
#else
using ::std::chrono::milliseconds;
#endif
// end milliseconds
// begin seconds
#ifdef BOOST_STL11_CHRONO_MAP_NO_SECONDS
#undef BOOST_STL11_CHRONO_MAP_NO_SECONDS
#else
using ::std::chrono::seconds;
#endif
// end seconds
// begin high_resolution_clock
#ifdef BOOST_STL11_CHRONO_MAP_NO_HIGH_RESOLUTION_CLOCK
#undef BOOST_STL11_CHRONO_MAP_NO_HIGH_RESOLUTION_CLOCK
#else
using ::std::chrono::high_resolution_clock;
#endif
// end high_resolution_clock
// begin treat_as_floating_point
#ifdef BOOST_STL11_CHRONO_MAP_NO_TREAT_AS_FLOATING_POINT
#undef BOOST_STL11_CHRONO_MAP_NO_TREAT_AS_FLOATING_POINT
#else
template<class _Rep> using treat_as_floating_point = ::std::chrono::treat_as_floating_point<_Rep>;
#endif
// end treat_as_floating_point
// begin minutes
#ifdef BOOST_STL11_CHRONO_MAP_NO_MINUTES
#undef BOOST_STL11_CHRONO_MAP_NO_MINUTES
#else
using ::std::chrono::minutes;
#endif
// end minutes
BOOST_STL11_CHRONO_MAP_NAMESPACE_END
#undef BOOST_STL11_CHRONO_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_CHRONO_MAP_NAMESPACE_END
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/chrono */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/mutex */
/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_MUTEX_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_MUTEX_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_MUTEX_MAP_NAMESPACE_BEGIN and BOOST_STL11_MUTEX_MAP_NAMESPACE_END to use this header file
#endif
#include <mutex>
BOOST_STL11_MUTEX_MAP_NAMESPACE_BEGIN
extern const char *boost_bindlib_in;
// begin call_once
#ifdef BOOST_STL11_MUTEX_MAP_NO_CALL_ONCE
#undef BOOST_STL11_MUTEX_MAP_NO_CALL_ONCE
#else
using ::std::call_once;
#endif
// end call_once
// begin try_lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_TRY_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_TRY_LOCK
#else
using ::std::try_lock;
#endif
// end try_lock
// begin unique_lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_UNIQUE_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_UNIQUE_LOCK
#else
template<class _Mutex> using unique_lock = ::std::unique_lock<_Mutex>;
#endif
// end unique_lock
// begin defer_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_DEFER_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_DEFER_LOCK_T
#else
using defer_lock_t = ::std::defer_lock_t;
#endif
// end defer_lock_t
// begin recursive_timed_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_TIMED_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_TIMED_MUTEX
#else
using recursive_timed_mutex = ::std::recursive_timed_mutex;
#endif
// end recursive_timed_mutex
// begin timed_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_TIMED_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_TIMED_MUTEX
#else
using timed_mutex = ::std::timed_mutex;
#endif
// end timed_mutex
// begin recursive_mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_RECURSIVE_MUTEX
#else
using recursive_mutex = ::std::recursive_mutex;
#endif
// end recursive_mutex
// begin lock_guard
#ifdef BOOST_STL11_MUTEX_MAP_NO_LOCK_GUARD
#undef BOOST_STL11_MUTEX_MAP_NO_LOCK_GUARD
#else
template<class _Mutex> using lock_guard = ::std::lock_guard<_Mutex>;
#endif
// end lock_guard
// begin mutex
#ifdef BOOST_STL11_MUTEX_MAP_NO_MUTEX
#undef BOOST_STL11_MUTEX_MAP_NO_MUTEX
#else
using mutex = ::std::mutex;
#endif
// end mutex
// begin try_to_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_TRY_TO_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_TRY_TO_LOCK_T
#else
using try_to_lock_t = ::std::try_to_lock_t;
#endif
// end try_to_lock_t
// begin once_flag
#ifdef BOOST_STL11_MUTEX_MAP_NO_ONCE_FLAG
#undef BOOST_STL11_MUTEX_MAP_NO_ONCE_FLAG
#else
using once_flag = ::std::once_flag;
#endif
// end once_flag
// begin lock
#ifdef BOOST_STL11_MUTEX_MAP_NO_LOCK
#undef BOOST_STL11_MUTEX_MAP_NO_LOCK
#else
using ::std::lock;
#endif
// end lock
// begin adopt_lock_t
#ifdef BOOST_STL11_MUTEX_MAP_NO_ADOPT_LOCK_T
#undef BOOST_STL11_MUTEX_MAP_NO_ADOPT_LOCK_T
#else
using adopt_lock_t = ::std::adopt_lock_t;
#endif
// end adopt_lock_t
BOOST_STL11_MUTEX_MAP_NAMESPACE_END
#undef BOOST_STL11_MUTEX_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_MUTEX_MAP_NAMESPACE_END
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/mutex */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */

/* Begin /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/thread */
/* This is an automatically generated bindings file. Don't modify it! */
#if !defined(BOOST_STL11_THREAD_MAP_NAMESPACE_BEGIN) || !defined(BOOST_STL11_THREAD_MAP_NAMESPACE_END)
#error You need to define BOOST_STL11_THREAD_MAP_NAMESPACE_BEGIN and BOOST_STL11_THREAD_MAP_NAMESPACE_END to use this header file
#endif
#include <thread>
BOOST_STL11_THREAD_MAP_NAMESPACE_BEGIN
extern const char *boost_bindlib_in;
// begin sleep_until
#ifdef BOOST_STL11_THREAD_MAP_NO_SLEEP_UNTIL
#undef BOOST_STL11_THREAD_MAP_NO_SLEEP_UNTIL
#else
namespace this_thread { using ::std::this_thread::sleep_until; }
#endif
// end sleep_until
// begin sleep_for
#ifdef BOOST_STL11_THREAD_MAP_NO_SLEEP_FOR
#undef BOOST_STL11_THREAD_MAP_NO_SLEEP_FOR
#else
namespace this_thread { using ::std::this_thread::sleep_for; }
#endif
// end sleep_for
// begin get_id
#ifdef BOOST_STL11_THREAD_MAP_NO_GET_ID
#undef BOOST_STL11_THREAD_MAP_NO_GET_ID
#else
namespace this_thread { using ::std::this_thread::get_id; }
#endif
// end get_id
// begin thread
#ifdef BOOST_STL11_THREAD_MAP_NO_THREAD
#undef BOOST_STL11_THREAD_MAP_NO_THREAD
#else
using thread = ::std::thread;
#endif
// end thread
// begin yield
#ifdef BOOST_STL11_THREAD_MAP_NO_YIELD
#undef BOOST_STL11_THREAD_MAP_NO_YIELD
#else
namespace this_thread { using ::std::this_thread::yield; }
#endif
// end yield
BOOST_STL11_THREAD_MAP_NAMESPACE_END
#undef BOOST_STL11_THREAD_MAP_NAMESPACE_BEGIN
#undef BOOST_STL11_THREAD_MAP_NAMESPACE_END
/* End /home/ned/boost.spinlock/include/boost/spinlock/bindlib/bind/stl11/std/thread */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */


// For dump
#include <ostream>

// Turn this on if you have a compiler which understands __transaction_relaxed
//#define BOOST_HAVE_TRANSACTIONAL_MEMORY_COMPILER

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN

BOOST_BINDLIB_DECLARE(BOOST_SPINLOCK_V1, "TODO FIXME") // TODO FIXME

/*! \struct lockable_ptr
* \brief Lets you use a pointer to memory as a spinlock :)
*/
template<typename T> struct lockable_ptr : atomic<T *>
{
BOOST_SPINLOCK_CONSTEXPR lockable_ptr(T *v=nullptr) : atomic<T *>(v) { }
//! Returns the memory pointer part of the atomic
T *get() BOOST_NOEXCEPT_OR_NOTHROW
{
union
{
T *v;
size_t n;
} value;
value.v=atomic<T *>::load(memory_order_relaxed);
value.n&=~(size_t)1;
return value.v;
}
//! Returns the memory pointer part of the atomic
const T *get() const BOOST_NOEXCEPT_OR_NOTHROW
{
union
{
T *v;
size_t n;
} value;
value.v=atomic<T *>::load(memory_order_relaxed);
value.n&=~(size_t)1;
return value.v;
}
T &operator*() BOOST_NOEXCEPT_OR_NOTHROW { return *get(); }
const T &operator*() const BOOST_NOEXCEPT_OR_NOTHROW { return *get(); }
T *operator->() BOOST_NOEXCEPT_OR_NOTHROW { return get(); }
const T *operator->() const BOOST_NOEXCEPT_OR_NOTHROW { return get(); }
};
template<typename T> struct spinlockbase
{
protected:
atomic<T> v;
public:
typedef T value_type;
BOOST_SPINLOCK_RELAXED_CONSTEXPR spinlockbase() BOOST_NOEXCEPT_OR_NOTHROW : v(0)
{
BOOST_SPINLOCK_ANNOTATE_RWLOCK_CREATE(this);
v.store(0, memory_order_release);
}
spinlockbase(const spinlockbase &) = delete;
//! Atomically move constructs
BOOST_SPINLOCK_RELAXED_CONSTEXPR spinlockbase(spinlockbase &&) BOOST_NOEXCEPT_OR_NOTHROW : v(0)
{
BOOST_SPINLOCK_ANNOTATE_RWLOCK_CREATE(this);
//v.store(o.v.exchange(0, memory_order_acq_rel));
v.store(0, memory_order_release);
}
~spinlockbase()
{
#ifdef BOOST_SPINLOCK_ENABLE_VALGRIND
if(v.load(memory_order_acquire))
{
BOOST_SPINLOCK_ANNOTATE_RWLOCK_RELEASED(this, true);
}
#endif
BOOST_SPINLOCK_ANNOTATE_RWLOCK_DESTROY(this);
}
spinlockbase &operator=(const spinlockbase &) = delete;
spinlockbase &operator=(spinlockbase &&) = delete;
//! Returns the raw atomic
BOOST_SPINLOCK_CONSTEXPR T load(memory_order o=memory_order_seq_cst) const BOOST_NOEXCEPT_OR_NOTHROW { return v.load(o); }
//! Sets the raw atomic
void store(T a, memory_order o=memory_order_seq_cst) BOOST_NOEXCEPT_OR_NOTHROW { v.store(a, o); }
//! If atomic is zero, sets to 1 and returns true, else false.
bool try_lock() BOOST_NOEXCEPT_OR_NOTHROW
{
#if ! BOOST_SPINLOCK_IN_THREAD_SANITIZER  // no early outs for the sanitizer
#ifdef BOOST_SPINLOCK_USE_VOLATILE_READ_FOR_AVOIDING_CMPXCHG
// MSVC's atomics always seq_cst, so use volatile read to create a true acquire
volatile T *_v=(volatile T *) &v;
if(*_v) // Avoid unnecessary cache line invalidation traffic
return false;
#else
if(v.load(memory_order_relaxed)) // Avoid unnecessary cache line invalidation traffic
return false;
#endif
#endif
#if defined(__i386__) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
// Intel is a lot quicker if you use XCHG instead of CMPXCHG. ARM is definitely not!
T ret=v.exchange(1, memory_order_acquire);
if(!ret)
#else
T expected=0;
bool ret=v.compare_exchange_weak(expected, 1, memory_order_acquire, memory_order_relaxed);
if(ret)
#endif
{
BOOST_SPINLOCK_ANNOTATE_RWLOCK_ACQUIRED(this, true);
return true;
}
else return false;
}
BOOST_SPINLOCK_CONSTEXPR bool try_lock() const BOOST_NOEXCEPT_OR_NOTHROW
{
return v.load(memory_order_consume) ? false : true;  // Avoid unnecessary cache line invalidation traffic
}
//! If atomic equals expected, sets to 1 and returns true, else false with expected updated to actual value.
bool try_lock(T &expected) BOOST_NOEXCEPT_OR_NOTHROW
{
T t(0);
#if ! BOOST_SPINLOCK_IN_THREAD_SANITIZER  // no early outs for the sanitizer
#ifdef BOOST_SPINLOCK_USE_VOLATILE_READ_FOR_AVOIDING_CMPXCHG
// MSVC's atomics always seq_cst, so use volatile read to create a true acquire
volatile T *_v = (volatile T *)&v;
if((t=*_v)) // Avoid unnecessary cache line invalidation traffic
#else
if((t=v.load(memory_order_relaxed))) // Avoid unnecessary cache line invalidation traffic
#endif
{
expected=t;
return false;
}
#endif
bool ret=v.compare_exchange_weak(expected, 1, memory_order_acquire, memory_order_relaxed);
if(ret)
{
BOOST_SPINLOCK_ANNOTATE_RWLOCK_ACQUIRED(this, true);
return true;
}
else return false;
}
//! Sets the atomic to zero
void unlock() BOOST_NOEXCEPT_OR_NOTHROW
{
BOOST_SPINLOCK_ANNOTATE_RWLOCK_RELEASED(this, true);
v.store(0, memory_order_release);
}
BOOST_SPINLOCK_RELAXED_CONSTEXPR bool int_yield(size_t) BOOST_NOEXCEPT_OR_NOTHROW { return false; }
};
template<typename T> struct spinlockbase<lockable_ptr<T>>
{
private:
lockable_ptr<T> v;
public:
typedef T *value_type;
spinlockbase() BOOST_NOEXCEPT_OR_NOTHROW { }
spinlockbase(const spinlockbase &) = delete;
//! Atomically move constructs
spinlockbase(spinlockbase &&o) BOOST_NOEXCEPT_OR_NOTHROW
{
v.store(o.v.exchange(nullptr, memory_order_acq_rel), memory_order_release);
}
spinlockbase &operator=(const spinlockbase &) = delete;
spinlockbase &operator=(spinlockbase &&) = delete;
//! Returns the memory pointer part of the atomic
T *get() BOOST_NOEXCEPT_OR_NOTHROW { return v.get(); }
T *operator->() BOOST_NOEXCEPT_OR_NOTHROW { return get(); }
//! Returns the raw atomic
T *load(memory_order o=memory_order_seq_cst) BOOST_NOEXCEPT_OR_NOTHROW { return v.load(o); }
#if 0 // Forces cmpxchng on everything else, so avoid if at all possible.
//! Sets the memory pointer part of the atomic preserving lockedness
void set(T *a) BOOST_NOEXCEPT_OR_NOTHROW
{
union
{
T *v;
size_t n;
} value;
T *expected;
do
{
value.v=v.load(memory_order_relaxed);
expected=value.v;
bool locked=value.n&1;
value.v=a;
if(locked) value.n|=1;
} while(!v.compare_exchange_weak(expected, value.v, memory_order_acquire, memory_order_relaxed));
}
#endif
//! Sets the raw atomic
void store(T *a, memory_order o=memory_order_seq_cst) BOOST_NOEXCEPT_OR_NOTHROW { v.store(a, o); }
bool try_lock() BOOST_NOEXCEPT_OR_NOTHROW
{
union
{
T *v;
size_t n;
} value;
value.v=v.load(memory_order_relaxed);
if(value.n&1) // Avoid unnecessary cache line invalidation traffic
return false;
T *expected=value.v;
value.n|=1;
return v.compare_exchange_weak(expected, value.v, memory_order_acquire, memory_order_relaxed);
}
void unlock() BOOST_NOEXCEPT_OR_NOTHROW
{
union
{
T *v;
size_t n;
} value;
value.v=v.load(memory_order_relaxed);
assert(value.n&1);
value.n&=~(size_t)1;
v.store(value.v, memory_order_release);
}
BOOST_SPINLOCK_RELAXED_CONSTEXPR bool int_yield(size_t) BOOST_NOEXCEPT_OR_NOTHROW { return false; }
};
namespace detail
{
template<bool use_pause> inline void smt_pause() BOOST_NOEXCEPT
{
};
template<> inline void smt_pause<true>() BOOST_NOEXCEPT
{
#ifdef BOOST_SMT_PAUSE
BOOST_SMT_PAUSE;
#endif
};
}
//! \brief How many spins to loop, optionally calling the SMT pause instruction on Intel
template<size_t spins, bool use_pause=true> struct spins_to_loop
{
template<class parenttype> struct policy : parenttype
{
static BOOST_CONSTEXPR_OR_CONST size_t spins_to_loop=spins;
BOOST_SPINLOCK_CONSTEXPR policy() {}
policy(const policy &) = delete;
BOOST_SPINLOCK_CONSTEXPR policy(policy &&o) BOOST_NOEXCEPT : parenttype(std::move(o)) { }
BOOST_SPINLOCK_RELAXED_CONSTEXPR inline bool int_yield(size_t n) BOOST_NOEXCEPT_OR_NOTHROW
{
if(parenttype::int_yield(n)) return true;
if(n>=spins) return false;
detail::smt_pause<use_pause>();
return true;
}
};
};
//! \brief How many spins to yield the current thread's timeslice
template<size_t spins> struct spins_to_yield
{
template<class parenttype> struct policy : parenttype
{
static BOOST_CONSTEXPR_OR_CONST size_t spins_to_yield=spins;
BOOST_SPINLOCK_CONSTEXPR policy() {}
policy(const policy &) = delete;
BOOST_SPINLOCK_CONSTEXPR policy(policy &&o) BOOST_NOEXCEPT : parenttype(std::move(o)) { }
BOOST_SPINLOCK_RELAXED_CONSTEXPR bool int_yield(size_t n) BOOST_NOEXCEPT_OR_NOTHROW
{
if(parenttype::int_yield(n)) return true;
if(n>=spins) return false;
this_thread::yield();
return true;
}
};
};
//! \brief How many spins to sleep the current thread
struct spins_to_sleep
{
template<class parenttype> struct policy : parenttype
{
BOOST_SPINLOCK_CONSTEXPR policy() {}
policy(const policy &) = delete;
BOOST_SPINLOCK_CONSTEXPR policy(policy &&o) BOOST_NOEXCEPT : parenttype(std::move(o)) { }
BOOST_SPINLOCK_RELAXED_CONSTEXPR bool int_yield(size_t n) BOOST_NOEXCEPT_OR_NOTHROW
{
if(parenttype::int_yield(n)) return true;
this_thread::sleep_for(chrono::milliseconds(1));
return true;
}
};
};
//! \brief A spin policy which does nothing
struct null_spin_policy
{
template<class parenttype> struct policy : parenttype
{
};
};
template<class T> inline bool is_lockable_locked(T &lockable) BOOST_NOEXCEPT_OR_NOTHROW;
/*! \class spinlock
\brief A policy configurable spin lock meeting BasicLockable and Lockable.

Meets the requirements of BasicLockable and Lockable. Also provides a get() and set() for the
type used for the spin lock.

So what's wrong with boost/smart_ptr/detail/spinlock.hpp then, and why
reinvent the wheel?

1. Non-configurable spin. AFIO needs a bigger spin than smart_ptr provides.

2. AFIO is C++ 11, and therefore can implement this in pure C++ 11 atomics.

3. I don't much care for doing writes during the spin. It generates an
unnecessary amount of cache line invalidation traffic. Better to spin-read
and only write when the read suggests you might have a chance.

4. This spin lock can use a pointer to memory as the spin lock. See locked_ptr<T>.
*/
template<typename T, template<class> class spinpolicy2=spins_to_loop<125>::policy, template<class> class spinpolicy3=spins_to_yield<250>::policy, template<class> class spinpolicy4=spins_to_sleep::policy> class spinlock : public spinpolicy4<spinpolicy3<spinpolicy2<spinlockbase<T>>>>
{
typedef spinpolicy4<spinpolicy3<spinpolicy2<spinlockbase<T>>>> parenttype;
public:
BOOST_SPINLOCK_CONSTEXPR spinlock() { }
spinlock(const spinlock &) = delete;
BOOST_SPINLOCK_CONSTEXPR spinlock(spinlock &&o) BOOST_NOEXCEPT : parenttype(std::move(o)) { }
void lock() BOOST_NOEXCEPT_OR_NOTHROW
{
for(size_t n=0;; n++)
{
if(parenttype::try_lock())
return;
parenttype::int_yield(n);
}
}
//! Locks if the atomic is not the supplied value, else returning false
bool lock(T only_if_not_this) BOOST_NOEXCEPT_OR_NOTHROW
{
for(size_t n=0;; n++)
{
T expected=0;
if(parenttype::try_lock(expected))
return true;
if(expected==only_if_not_this)
return false;
parenttype::int_yield(n);
}
}
};

//! \brief Determines if a lockable is locked. Type specialise this for performance if your lockable allows examination.
template<class T> inline bool is_lockable_locked(T &lockable) BOOST_NOEXCEPT_OR_NOTHROW
{
if(lockable.try_lock())
{
lockable.unlock();
return true;
}
return false;
}
// For when used with a spinlock
template<class T, template<class> class spinpolicy2, template<class> class spinpolicy3, template<class> class spinpolicy4> BOOST_SPINLOCK_CONSTEXPR inline T is_lockable_locked(const spinlock<T, spinpolicy2, spinpolicy3, spinpolicy4> &lockable) BOOST_NOEXCEPT_OR_NOTHROW
{
#ifdef BOOST_HAVE_TRANSACTIONAL_MEMORY_COMPILER
// Annoyingly the atomic ops are marked as unsafe for atomic transactions, so ...
return *((volatile T *) &lockable);
#else
return lockable.load(memory_order_consume);
#endif
}
// For when used with a locked_ptr
template<class T, template<class> class spinpolicy2, template<class> class spinpolicy3, template<class> class spinpolicy4> BOOST_SPINLOCK_CONSTEXPR inline bool is_lockable_locked(spinlock<lockable_ptr<T>, spinpolicy2, spinpolicy3, spinpolicy4> &lockable) BOOST_NOEXCEPT_OR_NOTHROW
{
return ((size_t) lockable.load(memory_order_consume))&1;
}

#ifndef BOOST_BEGIN_TRANSACT_LOCK
#ifdef BOOST_HAVE_TRANSACTIONAL_MEMORY_COMPILER
#undef BOOST_USING_INTEL_TSX
#define BOOST_BEGIN_TRANSACT_LOCK(lockable) __transaction_relaxed { (void) BOOST_SPINLOCK_V1_NAMESPACE::is_lockable_locked(lockable); {
#define BOOST_BEGIN_TRANSACT_LOCK_ONLY_IF_NOT(lockable, only_if_not_this) __transaction_relaxed { if((only_if_not_this)!=BOOST_SPINLOCK_V1_NAMESPACE::is_lockable_locked(lockable)) {
#define BOOST_END_TRANSACT_LOCK(lockable) } }
#define BOOST_BEGIN_NESTED_TRANSACT_LOCK(N) __transaction_relaxed
#define BOOST_END_NESTED_TRANSACT_LOCK(N)
#endif // BOOST_BEGIN_TRANSACT_LOCK
#endif

#ifndef BOOST_BEGIN_TRANSACT_LOCK
#define BOOST_BEGIN_TRANSACT_LOCK(lockable) { BOOST_SPINLOCK_V1_NAMESPACE::lock_guard<decltype(lockable)> __tsx_transaction(lockable);
#define BOOST_BEGIN_TRANSACT_LOCK_ONLY_IF_NOT(lockable, only_if_not_this) if(lockable.lock(only_if_not_this)) { BOOST_SPINLOCK_V1_NAMESPACE::lock_guard<decltype(lockable)> __tsx_transaction(lockable, BOOST_SPINLOCK_V1_NAMESPACE::adopt_lock_t());
#define BOOST_END_TRANSACT_LOCK(lockable) }
#define BOOST_BEGIN_NESTED_TRANSACT_LOCK(N)
#define BOOST_END_NESTED_TRANSACT_LOCK(N)
#endif // BOOST_BEGIN_TRANSACT_LOCK

BOOST_SPINLOCK_V1_NAMESPACE_END

#endif // BOOST_SPINLOCK_HPP
/* End /home/ned/boost.spinlock/include/boost/spinlock/spinlock.hpp */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/monad.hpp */


// For some odd reason, VS2015 really hates to do much inlining unless forced
#ifdef _MSC_VER
# define BOOST_SPINLOCK_FUTURE_CONSTEXPR BOOST_FORCEINLINE
# define BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR BOOST_FORCEINLINE
# define BOOST_SPINLOCK_FUTURE_MSVC_HELP BOOST_FORCEINLINE
#else
# define BOOST_SPINLOCK_FUTURE_CONSTEXPR BOOST_CONSTEXPR
# define BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR BOOST_CXX14_CONSTEXPR
# define BOOST_SPINLOCK_FUTURE_MSVC_HELP
#endif

/*! \file monad.hpp
\brief Provides a lightweight simple monadic value transport

\headerfile include/boost/spinlock/monad.hpp ""
*/

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN

namespace traits
{
namespace detail
{
// Gets the return type of F(A), returning a not_well_formed type if not well formed
template<class F, class A> struct get_return_type
{
struct not_well_formed {};
template<class _F, class _A> static not_well_formed test(...);
template<class _F, class _A> static auto test(_F &&f) -> decltype(f(std::declval<_A>()));
using type = decltype(test<F, A>(std::declval<F>()));
};

// Without Expression SFINAE (VS2015), I actually don't know of a better way :(
template<class T, class Arg> class has_call_operator2
{
struct Fallback { int operator()(Arg); };
struct Derived : T, Fallback { };

template<typename U, U> struct Check;

typedef char ArrayOfOne[1], ArrayOfTwo[2];

template<typename U> static ArrayOfOne & func(Check<int Fallback::*, &U::operator()> *);
template<typename U> static ArrayOfTwo & func(...);

public:
BOOST_STATIC_CONSTEXPR bool value = sizeof(func<Derived>(0)) == 2;
};
template <bool enable, typename F, typename Arg> struct has_call_operator : public std::false_type {};
template <typename F, typename Arg> struct has_call_operator<true, F, Arg> : public has_call_operator2<F, typename get_return_type<F, Arg>::type(Arg)>{};

template<bool _is_move, bool _is_auto, typename T=void> struct arg_form
{
BOOST_STATIC_CONSTEXPR bool is_rvalue = _is_move;
BOOST_STATIC_CONSTEXPR bool is_auto = _is_auto;
using non_auto_type = T;
};

template<int R> struct rank : rank<R - 1> { static_assert(R > 0, ""); };
template<> struct rank<0> {};

template<class F, class A> struct call_operator_argument_form
{
using return_type = typename get_return_type<F, A>::type;
using arg_type = typename std::decay<A>::type;

static arg_form<false, true> test(return_type(F::*)(const arg_type&)      , rank<1>);
static arg_form<false, true> test(return_type(F::*)(arg_type&)            , rank<2>);
static arg_form<true , true> test(return_type(F::*)(arg_type&&)           , rank<3>);
static arg_form<false, true> test(return_type(F::*)(arg_type)             , rank<4>);
static arg_form<false, true> test(return_type(F::*)(const arg_type&) const, rank<5>);
static arg_form<false, true> test(return_type(F::*)(arg_type&)       const, rank<6>);
static arg_form<true , true> test(return_type(F::*)(arg_type&&)      const, rank<7>);
static arg_form<false, true> test(return_type(F::*)(arg_type)        const, rank<8>);

template<class T> static arg_form<false, false, T> test(return_type(F::*)(T)             , rank<9>);
template<class T> static arg_form<false, false, T> test(return_type(F::*)(T&)            , rank<10>);
template<class T> static arg_form<true , false, T> test(return_type(F::*)(T&&)           , rank<11>);
template<class T> static arg_form<false, false, T> test(return_type(F::*)(T)        const, rank<12>);
template<class T> static arg_form<false, false, T> test(return_type(F::*)(T&)       const, rank<13>);
template<class T> static arg_form<true , false, T> test(return_type(F::*)(T&&)      const, rank<14>);

using result = decltype(test(&F::operator(), rank<15>()));

BOOST_STATIC_CONSTEXPR bool is_rvalue = result::is_rvalue;
BOOST_STATIC_CONSTEXPR bool is_auto = result::is_auto;
using type = typename result::non_auto_type;
};

template<class F, class A> struct function_argument_form
{
using return_type = typename get_return_type<F, A>::type;
using arg_type = typename std::decay<A>::type;

static arg_form<false, true> test(return_type(*)(const arg_type&)      , rank<1>);
static arg_form<false, true> test(return_type(*)(arg_type&)            , rank<2>);
static arg_form<true , true> test(return_type(*)(arg_type&&)           , rank<3>);
static arg_form<false, true> test(return_type(*)(arg_type)             , rank<4>);

template<class T> static arg_form<false, false, T> test(return_type(*)(T)             , rank<5>);
template<class T> static arg_form<false, false, T> test(return_type(*)(T&)            , rank<6>);
template<class T> static arg_form<true , false, T> test(return_type(*)(T&&)           , rank<7>);

using result = decltype(test(F(), rank<10>()));

BOOST_STATIC_CONSTEXPR bool is_rvalue = result::is_rvalue;
BOOST_STATIC_CONSTEXPR bool is_auto = result::is_auto;
using type = typename result::non_auto_type;
};

}

//! \brief Is the callable F called with Arg well formed?
template<class F, class A> struct is_callable_is_well_formed
{
using return_type = detail::get_return_type<F, A>;
//! \brief The type returned by the callable F when called with Arg
using type = typename return_type::type;
//! \brief Whether the call with Arg is well formed
BOOST_STATIC_CONSTEXPR bool value = !std::is_same<type, typename return_type::not_well_formed>::value;
};

//! \brief Is F a class type and does it have a call operator callable with Arg?
template<typename F, typename Arg> struct has_call_operator
: public detail::has_call_operator<std::is_class<F>::value, F, Arg>
{ };

namespace detail
{
template<bool enable, class F, class A> struct callable_argument_traits
{
//! \brief Is the callable F called with Arg well formed?
BOOST_STATIC_CONSTEXPR bool valid = false;
//! \brief Is the arg a rvalue ref?
BOOST_STATIC_CONSTEXPR bool is_rvalue = false;
//! \brief Is the arg a templated arg?
BOOST_STATIC_CONSTEXPR bool is_auto = false;
//! \brief If the arg is not a templated arg, it is this type
using type = void;
};
template<class F, class A> struct callable_argument_traits<true, F, A>
: public std::conditional<!std::is_function<F>::value && has_call_operator<std::is_class<F>::value, F, A>::value,
detail::call_operator_argument_form<F, A>,
detail::function_argument_form<F, A>
>::type
{
BOOST_STATIC_CONSTEXPR bool valid = true;
};
}

/*! \brief If callable F were to be called with A, tell me about the call.
*/
template<class F, class A> struct callable_argument_traits
: public detail::callable_argument_traits<is_callable_is_well_formed<F, A>::value, F, A>
{
//! The type returned by the callable when called with A
using return_type=typename is_callable_is_well_formed<F, A>::type;
};

}

namespace lightweight_futures
{

//! \brief Enumeration of the ways in which a monad operation may fail
enum class monad_errc {
already_set = 1,  //!< Attempt to store a value into the monad twice
no_state = 2      //!< Attempt to use without a state
};

namespace detail
{
class monad_category : public std::error_category
{
public:
virtual const char *name() const noexcept { return "monad"; }
virtual std::string message(int c) const
{
switch(c)
{
case 1: return "already_set";
case 2: return "no_state";
default: return "unknown";
}
}
};
}

/*! \brief Returns a reference to a monad error category. Note the address
of one of these may not be constant throughout the process as per the ISO spec.
*/
inline const detail::monad_category &monad_category()
{
static detail::monad_category c;
return c;
}

//! \brief A monad exception object
class BOOST_SYMBOL_VISIBLE monad_error : public std::logic_error
{
std::error_code _ec;
public:
monad_error(std::error_code ec) : std::logic_error(ec.message()), _ec(std::move(ec)) { }
const std::error_code &code() const noexcept { return _ec; }
};

inline std::error_code make_error_code(monad_errc e)
{
return std::error_code(static_cast<int>(e), monad_category());
}

inline std::error_condition make_error_condition(monad_errc e)
{
return std::error_condition(static_cast<int>(e), monad_category());
}

}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
template<> struct is_error_code_enum<BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad_errc> : std::true_type {};
template<> struct is_error_condition_enum<BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad_errc> : std::true_type {};
}

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN
namespace lightweight_futures {

template<typename R, class _error_type = std::error_code, class _exception_type = std::exception_ptr> class future;

namespace detail
{
template<typename R, class _error_type, class _exception_type, class throw_error> struct value_storage
{
typedef R value_type;
typedef _error_type error_type;
typedef _exception_type exception_type;
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4624)
#endif
union
{
value_type value;
error_type error;             // Often 16 bytes surprisingly
exception_type exception;     // Typically 8 bytes
future<value_type> *future_;  // Typically 8 bytes
};
#ifdef _MSC_VER
#pragma warning(pop)
#endif
enum class storage_type : unsigned char
{
empty,
value,
error,
exception,
future
} type;

BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_constructible = std::is_nothrow_copy_constructible<value_type>::value && std::is_nothrow_copy_constructible<exception_type>::value && std::is_nothrow_copy_constructible<error_type>::value;
BOOST_STATIC_CONSTEXPR bool is_nothrow_move_constructible = std::is_nothrow_move_constructible<value_type>::value && std::is_nothrow_move_constructible<exception_type>::value && std::is_nothrow_move_constructible<error_type>::value;
BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_assignable = std::is_nothrow_copy_assignable<value_type>::value && std::is_nothrow_copy_assignable<exception_type>::value && std::is_nothrow_copy_assignable<error_type>::value;
BOOST_STATIC_CONSTEXPR bool is_nothrow_move_assignable = std::is_nothrow_move_assignable<value_type>::value && std::is_nothrow_move_assignable<exception_type>::value && std::is_nothrow_move_assignable<error_type>::value;
BOOST_STATIC_CONSTEXPR bool is_nothrow_destructible = std::is_nothrow_destructible<value_type>::value && std::is_nothrow_destructible<exception_type>::value && std::is_nothrow_destructible<error_type>::value;

#if !defined(__GNUC__) || defined(__clang__)
/* If enabled GCC pukes during unwrap() with:
/usr/include/c++/5/type_traits:2204:7: error: static assertion failed: declval() must not be used!
static_assert(__declval_protector<_Tp>::__stop,
Apparently it's a known problem in constexpr compilation, and has been for some years now.
*/
BOOST_SPINLOCK_FUTURE_CONSTEXPR
#endif
value_storage() noexcept : type(storage_type::empty) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value) : value(v), type(storage_type::value) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const error_type &v) noexcept(std::is_nothrow_copy_constructible<error_type>::value) : error(v), type(storage_type::error) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(const exception_type &v) noexcept(std::is_nothrow_copy_constructible<exception_type>::value) : exception(v), type(storage_type::exception) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value) : value(std::move(v)), type(storage_type::value) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(error_type &&v) noexcept(std::is_nothrow_move_constructible<error_type>::value) : error(std::move(v)), type(storage_type::error) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR value_storage(exception_type &&v) noexcept(std::is_nothrow_move_constructible<exception_type>::value) : exception(std::move(v)), type(storage_type::exception) { }
struct emplace_t {};
template<class... Args> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit value_storage(emplace_t, Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Args...>::value) : value(std::forward<Args>(args)...), type(storage_type::value) { }

BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage(const value_storage &o) noexcept(is_nothrow_copy_constructible) : type(storage_type::empty)
{
switch (o.type)
{
case storage_type::empty:
break;
case storage_type::value:
new (&value) value_type(o.value);
break;
case storage_type::error:
new (&error) error_type(o.error);
break;
case storage_type::exception:
new (&exception) exception_type(o.exception);
break;
case storage_type::future:
abort();
break;
}
type = o.type;
}
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage(value_storage &&o) noexcept(is_nothrow_move_constructible) : type(storage_type::empty)
{
switch (o.type)
{
case storage_type::empty:
break;
case storage_type::value:
new (&value) value_type(std::move(o.value));
break;
case storage_type::error:
new (&error) error_type(std::move(o.error));
break;
case storage_type::exception:
new (&exception) exception_type(std::move(o.exception));
break;
case storage_type::future:
future_ = o.future_;
o.future_ = nullptr;
break;
}
type = o.type;
}
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage &operator=(const value_storage &o) noexcept(is_nothrow_destructible && is_nothrow_copy_constructible)
{
clear();
new (this) value_storage(o);
return *this;
}
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_storage &operator=(value_storage &&o) noexcept(is_nothrow_destructible && is_nothrow_move_constructible)
{
clear();
new (this) value_storage(std::move(o));
return *this;
}
BOOST_SPINLOCK_FUTURE_MSVC_HELP ~value_storage() noexcept(is_nothrow_destructible) { clear(); }
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void swap(value_storage &o) noexcept(is_nothrow_move_constructible)
{
if (type == o.type)
{
switch (type)
{
case storage_type::empty:
break;
case storage_type::value:
std::swap(value, o.value);
break;
case storage_type::error:
std::swap(error, o.error);
break;
case storage_type::exception:
std::swap(exception, o.exception);
break;
case storage_type::future:
std::swap(future_, o.future_);
break;
}
}
else
{
value_storage temp(std::move(o));
o = std::move(*this);
*this = std::move(temp);
}
}
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void clear() noexcept(is_nothrow_destructible)
{
switch (type)
{
case storage_type::empty:
break;
case storage_type::value:
value.~value_type();
type = storage_type::empty;
break;
case storage_type::error:
error.~error_type();
type = storage_type::empty;
break;
case storage_type::exception:
exception.~exception_type();
type = storage_type::empty;
break;
case storage_type::future:
future_ = nullptr;
type = storage_type::empty;
break;
}
}
static void throw_already_set()
{
// VS2015 RC errors with a member function redeclaration error, so workaround
//throw_error(monad_errc::already_set);
throw_error(static_cast<monad_errc>(static_cast<int>(monad_errc::already_set)));
}
template<class U> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_value(U &&v)
{
if (type != storage_type::empty)
throw_already_set();
new (&value) value_type(std::forward<U>(v));
type = storage_type::value;
}
template<class... Args> BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void emplace_value(Args &&... v)
{
if (type != storage_type::empty)
throw_already_set();
new (&value) value_type(std::forward<Args>(v)...);
type = storage_type::value;
}
void set_exception(exception_type e)
{
if (type != storage_type::empty)
throw_already_set();
new (&exception) exception_type(std::move(e));
type = storage_type::exception;
}
// Note to self: this can't be BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR
void set_error(error_type e)
{
if (type != storage_type::empty)
throw_already_set();
new (&error) error_type(std::move(e));
type = storage_type::error;
}
// Called by future to take ownership of storage from promise
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR void set_future(future<value_type> *f) noexcept(is_nothrow_destructible)
{
// Always overwrites existing storage
clear();
future_ = f;
type = storage_type::future;
}
};

struct throw_monad_error
{
BOOST_SPINLOCK_FUTURE_MSVC_HELP throw_monad_error(monad_errc ec)
{
throw monad_error(ec);
}
};
}

template<typename R, class _error_type = std::error_code, class _exception_type = std::exception_ptr, class throw_error = detail::throw_monad_error> class monad;

namespace detail
{
template<class M> struct do_unwrap;
template<class R, class _error_type, class _exception_type, class throw_error> struct do_unwrap<monad<R, _error_type, _exception_type, throw_error>>
{
typedef monad<R, _error_type, _exception_type, throw_error> input_type;
typedef input_type output_type;
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(const input_type &v) const { return v; }
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(input_type &&v) const { return std::move(v); }
};
template<class R, class _error_type, class _exception_type, class throw_error1, class throw_error2> struct do_unwrap<monad<monad<R, _error_type, _exception_type, throw_error1>, _error_type, _exception_type, throw_error2>>
{
typedef monad<monad<R, _error_type, _exception_type, throw_error1>, _error_type, _exception_type, throw_error2> input_type;
typedef typename input_type::value_type unwrapped_type;
typedef typename do_unwrap<unwrapped_type>::output_type output_type;
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(const input_type &v) const
{
if(v.has_error())
return do_unwrap<unwrapped_type>()(v.get_error());
else if(v.has_exception())
return do_unwrap<unwrapped_type>()(v.get_exception());
else if(v.has_value())
return do_unwrap<unwrapped_type>()(v.get());
else
return do_unwrap<unwrapped_type>()(unwrapped_type());
}
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR output_type operator()(input_type &&v) const
{
if(v.has_error())
return do_unwrap<unwrapped_type>()(std::move(v).get_error());
else if(v.has_exception())
return do_unwrap<unwrapped_type>()(std::move(v).get_exception());
else if(v.has_value())
return do_unwrap<unwrapped_type>()(std::move(v).get());
else
return do_unwrap<unwrapped_type>()(unwrapped_type());
}
};

template<class M> struct is_monad : std::false_type {};
template<class R, class _error_type, class _exception_type, class throw_error> struct is_monad<monad<R, _error_type, _exception_type, throw_error>> : std::true_type{};

// Is the monad M's contents directly constructible from an R, not allowing a monad<monad<int>> being constructible from an int
template<class M, class R> struct is_monad_constructible : public std::is_constructible<typename M::value_type, R> {};
template<class M> struct is_monad_constructible<M, typename M::error_type> : public std::true_type{};
template<class M> struct is_monad_constructible<M, typename M::exception_type> : public std::true_type{};
template<class M> struct is_monad_constructible<M, typename M::empty_type> : public std::true_type{};
template<class M, class _error_type1, class _exception_type1, class throw_error1, class _error_type2, class _exception_type2, class throw_error2> struct is_monad_constructible<monad<monad<M, _error_type2, _exception_type2, throw_error2>, _error_type1, _exception_type1, throw_error1>, M> : public std::false_type{};
template<class F, class M> struct bind_map_parameter_validation
{
// Figure out what the callable takes
typedef traits::callable_argument_traits<F, typename M::value_type> f_value_traits;
typedef traits::callable_argument_traits<F, typename M::error_type> f_error_traits;
typedef traits::callable_argument_traits<F, typename M::exception_type> f_exception_traits;
typedef traits::callable_argument_traits<F, typename M::empty_type> f_empty_traits;
BOOST_STATIC_CONSTEXPR bool callable_takes_anything=f_value_traits::is_auto;
BOOST_STATIC_CONSTEXPR bool callable_is_uncallable=!callable_takes_anything && !is_monad<typename M::value_type>::value && (f_value_traits::valid+f_error_traits::valid+f_exception_traits::valid+f_empty_traits::valid)==0;
BOOST_STATIC_CONSTEXPR bool callable_is_ambiguous=!callable_takes_anything && !is_monad<typename M::value_type>::value && (f_value_traits::valid+f_error_traits::valid+f_exception_traits::valid+f_empty_traits::valid)>1;

// Error out common mistakes in the callable parameter
static_assert(!callable_is_uncallable,
"Callable does not have an auto nor templated parameter and is not well formed for none of a value_type, an error_type, an exception_type nor an empty_type. You probably need to adjust the parameter being taken by your callable");
static_assert(!callable_is_ambiguous,
"Callable does not have an auto nor templated parameter, yet is well formed for more than one of value_type, error_type, exception_type and empty_type. As cannot disambiguate meaning, stopping");
static_assert(!f_value_traits::valid || (callable_takes_anything || std::is_convertible<typename f_value_traits::type, typename M::value_type>::value),
"A value_type consuming callable must have a parameter type which can be implicitly converted to from a value_type, or be an auto or templated parameter");
static_assert(!f_error_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_error_traits::is_rvalue && std::is_same<typename f_error_traits::type, typename M::error_type>::value),
"An error_type consuming callable must take an error_type by value");
static_assert(!f_exception_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_exception_traits::is_rvalue && std::is_same<typename f_exception_traits::type, typename M::exception_type>::value),
"An exception_type consuming callable must take an exception_type by value");
static_assert(!f_empty_traits::valid || callable_takes_anything || is_monad<typename M::value_type>::value || (!f_empty_traits::is_rvalue && std::is_same<typename f_empty_traits::type, typename M::empty_type>::value),
"An empty_type consuming callable must take an empty_type by value");

// Figure out what the callable returns
using return_type = typename std::conditional<f_value_traits::valid,
typename f_value_traits::return_type,
typename std::conditional<f_error_traits::valid,
typename f_error_traits::return_type,
typename std::conditional<f_exception_traits::valid,
typename f_exception_traits::return_type,
typename std::conditional<f_empty_traits::valid,
typename f_empty_traits::return_type,
void
>::type
>::type
>::type
>::type;

// Error out common mistakes in the return type
static_assert(!f_error_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
"An error_type consuming callable must return a type convertible to the monad type");
static_assert(!f_exception_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
"An exception_type consuming callable must return a type convertible to the monad type");
static_assert(!f_empty_traits::valid || callable_takes_anything || std::is_same<void, return_type>::value || is_monad_constructible<M, return_type>::value,
"An empty_type consuming callable must return a type convertible to the monad type");
};

// Enable calling callable if is well formed and is either not auto or we're doing value_type
template<class C, class U, class value_type, bool additional=true, class value_type2=void> struct enable_if_callable_valid
: std::enable_if<additional && traits::callable_argument_traits<C, U>::valid
&& (!traits::callable_argument_traits<C, U>::is_auto || std::is_same<U, value_type>::value || std::is_same<U, value_type2>::value)>
{};
template<class C, class U, class value_type, bool additional> struct enable_if_callable_valid<C, U, value_type, additional, void>
: std::enable_if<additional && traits::callable_argument_traits<C, U>::valid
&& (!traits::callable_argument_traits<C, U>::is_auto || std::is_same<U, value_type>::value)>
{};
/* Invokes the callable passed to then() and bind() and map() optionally folding any monad return type
R is the type returned by the callable
C is the callable
M is the monad

Call operator is invoked with any of value, error, exception or empty. If not well
formed, passes through input.
*/
template<bool fold_monadic_return, class R, class C, class M> struct do_continuation;
// For when R is not a monad or map()
template<bool fold_monadic_return, class R, class C, class T, class _error_type, class _exception_type, class throw_error> struct do_continuation<fold_monadic_return, R, C, monad<T, _error_type, _exception_type, throw_error>>
{
typedef C callable_type;
// If the return type is an error_type or exception_type or void, reuse T else use R
typedef monad<typename std::conditional<
std::is_same<R, _error_type>::value || std::is_same<R, _exception_type>::value || std::is_same<R, void>::value,
T, R
>::type, _error_type, _exception_type, throw_error> output_type;
callable_type _c;
BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(const callable_type &c) : _c(c) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &&c) : _c(std::move(c)) { }
template<class U,
typename=typename enable_if_callable_valid<C, U, T, !std::is_same<R, void>::value>::type
> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<4>) const
{
return traits::callable_argument_traits<C, U>::is_rvalue
? output_type(_c(std::move(v)))
: output_type(_c(U(v)));
}
template<class U,
typename = typename enable_if_callable_valid<C, U, T, std::is_same<R, void>::value>::type
> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<3>) const
{
return traits::callable_argument_traits<C, U>::is_rvalue
? (_c(std::move(v)), output_type())
: (_c(U(v)), output_type());
}
template<class U, typename=typename std::enable_if<std::is_constructible<output_type, U>::value>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<2>) const { return output_type(std::forward<U>(v)); }
template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&, traits::detail::rank<1>) const { return output_type(); }
};
// For when R is a monad
template<class R, class _error_type1, class _exception_type1, class throw_error1,
class C,
class T, class _error_type2, class _exception_type2, class throw_error2> struct do_continuation<true,
monad<R, _error_type1, _exception_type1, throw_error1>,
C,
monad<T, _error_type2, _exception_type2, throw_error2>
>
{
typedef C callable_type;
typedef monad<R, _error_type1, _exception_type1, throw_error1> output_type;
typedef monad<T, _error_type2, _exception_type2, throw_error2> input_type;
callable_type _c;
BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(const callable_type &c) : _c(c) { }
BOOST_SPINLOCK_FUTURE_CONSTEXPR do_continuation(callable_type &&c) : _c(std::move(c)) { }
template<class U,
typename = typename enable_if_callable_valid<C, U, input_type, !std::is_same<R, void>::value, T>::type
> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<4>) const
{
return traits::callable_argument_traits<C, U>::is_rvalue
? output_type(_c(std::move(v)))
: output_type(_c(U(v)));
}
template<class U,
typename = typename enable_if_callable_valid<C, U, input_type, std::is_same<R, void>::value, T>::type
> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<3>) const
{
return traits::callable_argument_traits<C, U>::is_rvalue
? (_c(std::move(v)), output_type())
: (_c(U(v)), output_type());
}
template<class U, typename=typename std::enable_if<std::is_constructible<output_type, U>::value>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&v, traits::detail::rank<2>) const { return output_type(std::forward<U>(v)); }
template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR output_type operator()(U &&, traits::detail::rank<1>) const { return output_type(); }
};

// TODO FIXME: do_then should have specially reduced simple lightweight implementation
template<class R, class C, class M> using do_then = do_continuation<true,  R, C, M>;
template<class R, class C, class M> using do_bind = do_continuation<true,  R, C, M>;
template<class R, class C, class M> using do_map  = do_continuation<false, R, C, M>;
}

//! \brief True if the type passed is a monad or a reference to a monad
template<class M> struct is_monad : detail::is_monad<typename std::decay<M>::type> { };

/*! \class monad
\brief Implements a lightweight simple monadic value transport with the same semantics and API as a future
\tparam R The expected type
\tparam _error_type The type matching the semantics of `std::error_code` to use
\tparam _exception_type The type matching the semantics of `std::exception_ptr` to use
\tparam throw_error A callable with specification void(monad_errc) to call when needing to throw an exception
matching monad_errc

This monad can hold a fixed variant list of empty, a type `R`, a lightweight `error_type` or a
heavier `exception_type` at a space cost of `max(20, sizeof(R)+4)`. Features:

- Very lightweight on build times and run times up to the point of zero execution cost and just a four
byte space overhead. See below for benchmarks. Requires min clang 3.2, GCC 4.7 or VS2015.
- Just enough monad, nothing more, nothing fancy. Replicates the future API, so if you know how to
use a future you already know how to use this.
- Enables convenient all-`noexcept` mathematically verifiable close semantic design, so
why bother with Rust anymore? :)
- Can replace most uses of `optional<T>`.
- Deep integration with lightweight future-promise (i.e. async monadic programming) also in this library.
- Comprehensive unit testing and validation suite.
- Mirrors `noexcept` of type R.
- Type R can have no default constructor, move nor copy.
- Works inside a STL container, and type R can be a STL container.
- No comparison operations nor hashing is provided, deliberately to keep things simple.

## Notes: ##

Something which might surprise people is that:

\code
monad<std::string> a("niall");
monad<std::string> b(std::move(a));
BOOST_CHECK(a.has_value());  // true
\endcode

Moving a monad does a move of its underlying contents, so any contents remain at whatever
the move constructor for that content leaves things. In other words, a moved from monad
does not become empty, if you want that then call clear().

So long as you avoid the exception_type code paths, this implementation will be
ideally reduced to as few assembler instructions as possible by most recent compilers [1]
which can include exactly zero assembler instructions output. This monad is therefore
identical in terms of execution overhead to using the R type you specify directly - you
get the monadic functionality totally free of execution overhead where the compiler is able
to reduce it to such.

A similar thing applies to error_type which is a lightweight implementation on most
systems. An exception is on VS2015 as the lvalue reference to system_category appears
to be constructed via thread safe once routine called "Immortalize", so when you
construct an error_type on MSVC you'll force a memory synchronisation during the constructor
only. error_types are very cheap to pass around though as they are but an integer and a lvalue ref,
though I see that on GCC and clang 16 bytes is always copied around instead of completely
eliding the copy.

exception_type is also pretty good on anything but MSVC, though never zero assembler
instructions. As soon as an exception_type \em could be created, you'll force out about twenty
instructions most of which won't be executed in practice. Unfortunately, MSVC churns out
about 2000 assembler instructions as soon as you might touch an exception_type, I've raised
this with Microsoft and it looks to be hard for them to fix due to backwards compatibility
reasons.

[1]: GCC 5.1 does a perfect job, VS2015 does a good job, clang 3.7 not so great. See next section.

## Complexity guarantees ##

These x64 opcode guarantees are empirically determined by the unit test suite, and the per-commit
CI testing will fail if they suddenly are exceeded. The maximum is calculated by taking a monad
in from a non-visible source where the compiler has to generate code paths to handle an unknown
input state, whereas the minimum is calculated by setting a monad's state in view of the compiler's
optimiser such that it can usually completely elide opcodes generated (though note that varies
enormously by compiler to the extent that the known code generates more opcodes than the unknown code). All monads are `monad<int>`.

<dl>
<dt>clang 3.7</dt>
<dd>59 opcodes <= Value transport <= 37 opcodes<br></dd>
<dd>7 opcodes <= Error transport <= 52 opcodes<br></dd>
<dd>38 opcodes <= Exception transport <= 39 opcodes</dd>
<dd>62 opcodes <= then() <= 84 opcodes</dd>
<dd>5 opcodes <= bind() <= 44 opcodes</dd>
<dt>GCC 5.1</dt>
<dd>1 opcodes <= Value transport <= 113 opcodes<br></dd>
<dd>8 opcodes <= Error transport <= 119 opcodes<br></dd>
<dd>22 opcodes <= Exception transport <= 214 opcodes</dd>
<dd>4 opcodes <= then() <= 154 opcodes</dd>
<dd>5 opcodes <= bind() <= 44 opcodes</dd>
<dt>VS2015</dt>
<dd>4 opcodes <= Value transport <= 1881 opcodes<br></dd>
<dd>6 opcodes <= Error transport <= 164 opcodes<br></dd>
<dd>1946 opcodes <= Exception transport <= 1936 opcodes</dd>
<dd>2029 opcodes <= then() <= 2030 opcodes</dd>
<dd>155 opcodes <= bind() <= 156 opcodes</dd>
</dl>

## Examples ##

\snippet unittests.cpp monad_example

### As an alternative to `optional<T>` ###

Something not so obvious is that this monad can have an empty state, and therefore
can stand in for `optional<T>` like this:

\snippet unittests.cpp optional_example

The API is actually not too distant from `optional<T>`, so with a bit of regex find and replace
you could use `monad<T>` instead.

The need for `monad<T>` to be able to be empty was to make exception throws by T during copy and move
construction lightweight. If that happens, the monad always has empty state afterwards.
*/
template<typename R, class _error_type, class _exception_type, class throw_error> class monad
{
static_assert(!std::is_same<R, _error_type>::value, "R and error_type cannot be the same type");
static_assert(!std::is_same<R, _exception_type>::value, "R and exception_type cannot be the same type");
static_assert(!std::is_same<_error_type, _exception_type>::value, "error_type and exception_type cannot be the same type");
public:
//! \brief The type potentially held by the monad
typedef R value_type;
//! \brief The error code potentially held by the monad
typedef _error_type error_type;
//! \brief The exception ptr potentially held by the monad
typedef _exception_type exception_type;
//! \brief Tag type for an empty monad
struct empty_type { typedef monad monad_type; };
//! \brief Rebind this monad type into a different value_type
template<typename U> using rebind = monad<U, _error_type, _exception_type, throw_error>;
private:
typedef detail::value_storage<value_type, error_type, exception_type, throw_error> value_storage_type;
value_storage_type _storage;
static void throw_nostate()
{
// VS2015 RC errors with a member function redeclaration error, so workaround
//throw_error(monad_errc::no_state);
throw_error(static_cast<monad_errc>(static_cast<int>(monad_errc::no_state)));
}
protected:
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(value_storage_type &&s) : _storage(std::move(s)) { }
public:
//! \brief This monad will never throw exceptions during copy construction
BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_constructible = value_storage_type::is_nothrow_copy_constructible;
//! \brief This monad will never throw exceptions during move construction
BOOST_STATIC_CONSTEXPR bool is_nothrow_move_constructible = value_storage_type::is_nothrow_move_constructible;
//! \brief This monad will never throw exceptions during copy assignment
BOOST_STATIC_CONSTEXPR bool is_nothrow_copy_assignable = value_storage_type::is_nothrow_destructible && value_storage_type::is_nothrow_copy_constructible;
//! \brief This monad will never throw exceptions during move assignment
BOOST_STATIC_CONSTEXPR bool is_nothrow_move_assignable = value_storage_type::is_nothrow_destructible && value_storage_type::is_nothrow_move_constructible;
//! \brief This monad will never throw exceptions during destruction
BOOST_STATIC_CONSTEXPR bool is_nothrow_destructible = value_storage_type::is_nothrow_destructible;

//! \brief Default constructor, initialises to empty
monad() = default;
//! \brief Implicit constructor of an empty monad
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(empty_type) : monad() { }
//! \brief Implicit constructor from a value_type by copy
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value) : _storage(v) { }
//! \brief Implicit constructor from a value_type by move
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value) : _storage(std::move(v)) { }
/*! \brief Explicit constructor of a value_type allowing emplacement with no other means of construction. Only available
if value_type which can't be a monad can be constructed from Args and if either there is more than one Arg or the Arg is not a value_type, an
error_type, an exception_type nor an empty_type.
*/
#ifdef DOXYGEN_IS_IN_THE_HOUSE
template<class... Args> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit monad(Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Arg, Args...>::value);
#else
template<class Arg, class... Args,
typename = typename std::enable_if<
!is_monad<value_type>::value
&& std::is_constructible<value_type, Arg, Args...>::value
&& (sizeof...(Args)!=0 ||
(!std::is_same<value_type, typename std::decay<Arg>::type>::value
&& !std::is_same<error_type, typename std::decay<Arg>::type>::value
&& !std::is_same<exception_type, typename std::decay<Arg>::type>::value
&& !std::is_same<empty_type, typename std::decay<Arg>::type>::value))
>::type> BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit monad(Arg &&arg, Args &&... args) noexcept(std::is_nothrow_constructible<value_type, Arg, Args...>::value) : _storage(typename value_storage_type::emplace_t(), std::forward<Arg>(arg), std::forward<Args>(args)...) { }
#endif
//! \brief Implicit constructor from an initializer list
template<class U> BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(std::initializer_list<U> l) noexcept(std::is_nothrow_constructible<value_type, std::initializer_list<U>>::value) : _storage(typename value_storage_type::emplace_t(), std::move(l)) { }
//! \brief Implicit constructor from a error_type by copy
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(const error_type &v) noexcept(std::is_nothrow_copy_constructible<error_type>::value) : _storage(v) { }
//! \brief Implicit constructor from a error_type by move
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(error_type &&v) noexcept(std::is_nothrow_move_constructible<error_type>::value) : _storage(std::move(v)) { }
//! \brief Implicit constructor from a exception_type by copy
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(const exception_type &v) noexcept(std::is_nothrow_copy_constructible<exception_type>::value) : _storage(v) { }
//! \brief Implicit constructor from a exception_type by move
BOOST_SPINLOCK_FUTURE_CONSTEXPR monad(exception_type &&v) noexcept(std::is_nothrow_move_constructible<exception_type>::value) : _storage(std::move(v)) { }
//! \brief Move constructor
monad(monad &&) = default;
//! \brief Move assignment. Firstly clears any existing state, so exception throws during move will leave the monad empty.
monad &operator=(monad &&) = default;
//! \brief Copy constructor
monad(const monad &v) = default;
//! \brief Copy assignment. Firstly clears any existing state, so exception throws during copy will leave the monad empty.
monad &operator=(const monad &) = default;

//! \brief True if monad contains a value_type
BOOST_SPINLOCK_FUTURE_CONSTEXPR explicit operator bool() const noexcept { return has_value(); }
//! \brief True if monad is not empty
BOOST_SPINLOCK_FUTURE_CONSTEXPR bool is_ready() const noexcept
{
return _storage.type!=value_storage_type::storage_type::empty;
}
//! \brief True if monad is empty
BOOST_SPINLOCK_FUTURE_CONSTEXPR bool empty() const noexcept
{
return _storage.type==value_storage_type::storage_type::empty;
}
//! \brief True if monad contains a value_type
BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_value() const noexcept
{
return _storage.type==value_storage_type::storage_type::value;
}
//! \brief True if monad contains an error_type
BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_error() const noexcept
{
return _storage.type==value_storage_type::storage_type::error;
}
//! \brief True if monad contains an exception_type or error_type
BOOST_SPINLOCK_FUTURE_CONSTEXPR bool has_exception() const noexcept
{
return _storage.type==value_storage_type::storage_type::exception || _storage.type==value_storage_type::storage_type::error;
}

//! \brief Swaps one monad for another
BOOST_SPINLOCK_FUTURE_MSVC_HELP void swap(monad &o) noexcept(is_nothrow_move_constructible)
{
_storage.swap(o._storage);
}
//! \brief Destructs any state stored, resetting to empty
BOOST_SPINLOCK_FUTURE_MSVC_HELP void clear() noexcept(is_nothrow_destructible)
{
_storage.clear();
}

private:
BOOST_SPINLOCK_FUTURE_MSVC_HELP void _get_value() const &&
{
if(!is_ready())
throw_nostate();
if(has_error() || has_exception())
{
if(has_error())
throw std::system_error(_storage.error);
if(has_exception())
std::rethrow_exception(_storage.exception);
}
}
public:
//! \brief If contains a value_type, returns a lvalue reference to it, else throws an exception of future_error(no_state), system_error or the exception_type.
BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &get() &
{
std::move(*this)._get_value();
return _storage.value;
}
//! \brief If contains a value_type, returns a lvalue reference to it, else throws an exception of future_error(no_state), system_error or the exception_type.
BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &value() &
{
std::move(*this)._get_value();
return _storage.value;
}
//! \brief If contains a value_type, returns a const lvalue reference to it, else throws an exception of future_error(no_state), system_error or the exception_type.
BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &get() const &
{
std::move(*this)._get_value();
return _storage.value;
}
//! \brief If contains a value_type, returns a const lvalue reference to it, else throws an exception of future_error(no_state), system_error or the exception_type.
BOOST_SPINLOCK_FUTURE_MSVC_HELP const value_type &value() const &
{
std::move(*this)._get_value();
return _storage.value;
}
//! \brief If contains a value_type, returns a rvalue reference to it, else throws an exception of future_error(no_state), system_error or the exception_type.
BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&get() &&
{
std::move(*this)._get_value();
return std::move(_storage.value);
}
//! \brief If contains a value_type, returns a rvalue reference to it, else throws an exception of future_error(no_state), system_error or the exception_type.
BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type &&value() &&
{
std::move(*this)._get_value();
return std::move(_storage.value);
}
//! \brief If contains a value_type, return that value type, else return the supplied value_type
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &get_or(value_type &v) & noexcept
{
return has_value() ? _storage.value : v;
}
//! \brief If contains a value_type, return that value type, else return the supplied value_type
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &value_or(value_type &v) & noexcept
{
return has_value() ? _storage.value : v;
}
//! \brief If contains a value_type, return that value type, else return the supplied value_type
BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &get_or(const value_type &v) const & noexcept
{
return has_value() ? _storage.value : v;
}
//! \brief If contains a value_type, return that value type, else return the supplied value_type
BOOST_SPINLOCK_FUTURE_CONSTEXPR const value_type &value_or(const value_type &v) const & noexcept
{
return has_value() ? _storage.value : v;
}
//! \brief If contains a value_type, return that value type, else return the supplied value_type
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&get_or(value_type &&v) && noexcept
{
return has_value() ? std::move(_storage.value) : std::move(v);
}
//! \brief If contains a value_type, return that value type, else return the supplied value_type
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR value_type &&value_or(value_type &&v) && noexcept
{
return has_value() ? std::move(_storage.value) : std::move(v);
}
//! \brief Disposes of any existing state, setting the monad to a copy of the value_type
BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(const value_type &v) { _storage.clear(); _storage.set_value(v); }
//! \brief Disposes of any existing state, setting the monad to a move of the value_type
BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(value_type &&v) { _storage.clear(); _storage.set_value(std::move(v)); }
//! \brief Disposes of any existing state, setting the monad to an emplaced construction
template<class... Args> BOOST_SPINLOCK_FUTURE_MSVC_HELP void emplace(Args &&... args) { _storage.clear(); _storage.emplace_value(std::forward<Args>(args)...); }

//! \brief If contains an error_type, returns that error_type, else returns a null error_type. Can only throw the exception future_error(no_state) if empty.
BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error() const
{
if(!is_ready())
throw_nostate();
if(!has_error())
return error_type();
return _storage.error;
}
//! \brief If contains an error_type, returns that error_type else returns the error_type supplied
BOOST_SPINLOCK_FUTURE_MSVC_HELP error_type get_error_or(error_type e) const noexcept { return has_error() ? _storage.error : std::move(e); }
//! \brief Disposes of any existing state, setting the monad to the error_type
BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_error(error_type v) { _storage.clear(); _storage.set_error(std::move(v)); }

//! \brief If contains an exception_type, returns that exception_type. If contains an error_type, returns system_error(error_type). If contains a value_type, returns a null exception_type. Can only throw the exception future_error(no_state) if empty.
BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception() const
{
if(!is_ready())
throw_nostate();
if(!has_error() && !has_exception())
return exception_type();
if(has_error())
return std::make_exception_ptr(std::system_error(_storage.error));
if(has_exception())
return _storage.exception;
return exception_type();
}
//! \brief If contains an exception_type, returns that exception_type else returns the exception_type supplied
BOOST_SPINLOCK_FUTURE_MSVC_HELP exception_type get_exception_or(exception_type e) const noexcept { return has_exception() ? _storage.exception : std::move(e); }
//! \brief Disposes of any existing state, setting the monad to the exception_type
BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_exception(exception_type v) { _storage.clear(); _storage.set_exception(std::move(v)); }
//! \brief Disposes of any existing state, setting the monad to make_exception_type(forward<E>(e))
template<typename E> BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_exception(E &&e)
{
set_exception(make_exception_type(std::forward<E>(e)));
}

/*! \name Monadic programming primitives unwrap(), then(), bind() and map()

Classic monadic programming consists of a sequence of nested functional operations:
<dl>
<dt>JOIN (single): monad<monad<T>>.get() -> monad<T></dt>
<dt>JOIN (maximum): monad<monad<monad<monad<T>>>>.unwrap() -> monad<T></dt>
<dd>Whatever is the first monad containing a non-monad is returned.</dd>
<dt>MAP: monad<T>.map(R(T)) -> monad<R></dt>
<dd>If callable maps T to R, map() maps a monad<T> to a monad<R> if monad<T>
contains a T. If it contains an error or is empty, that is passed through.</dd>
<dt>BIND: monad<T>.bind(monad<R>(T)) -> monad<R></dt>
<dt>BIND: monad<T>.bind(R(T)) -> monad<R></dt>
<dd>If callable maps T to monad<R> and if monad<T> contains a T, then bind() maps
a monad<T> to a monad<R> else if callable maps T to R and if monad<T> contains a T,
bind() maps a monad<T> to a monad<R>. In other words, returning a monad from the
callable does not wrap it in another monad. If the originating monad did not
contain a T, that is passed through.</dd>
</dl>
We also support monad<T>.then(R(monad<T>)) for semantic equivalence to futures where the
callable is called with the originating monad. This
acts like bind(), so if the callable returns a monad it is not wrapped in another
monad. Unlike map() or bind(), then() always calls the callable no matter what the
monad contains, so it is up to you to interrogate the monad. Note that the originating
monad is passed by const lvalue ref unless the callable takes a rvalue ref to the monad.

A quick use example:
\snippet unittests.cpp monad_bind_example

You will note in the code example that the type of the callable for bind() and map()
determines what operation happens. Here are the rules:
- If the monad contains a T and the callable takes a T or an `auto`, then:
- If the callable takes a T or any reference to a T which isn't an rvalue reference,
the T is passed by const lvalue reference (i.e. copy semantics).
- If the callable takes a T by non-const rvalue reference, the T is passed by rvalue ref.
This lets you move from the value held by the originating monad if so desired.
If the monad doesn't contain a T, pass it through but into whatever new monad type
returned by the callable.
\warning The current implementation requires you to specify a non-dependent return
type for all generic lambdas, else you'll get compile errors where the compiler tried
to insert `error_type`, `exception_type` etc when it was trying to figure out if the
return type is correct. A future implementation (once VS2015 has Expression SFINAE) may
remove this restriction, until then just hard specify your return types if your lambdas
take an `auto`, or use lambdas not taking `auto`.

- If the monad contains an `error_type` and the callable takes an `error_type`, then
call the callable, else pass through the monad. For this reason, any callable taking
an `error_type` must always return the same monad type as the originating monad.
- If the monad contains an `error_type` or an `exception_type` and the callable takes
an `exception_type`, then call the callable, else pass through the monad. For this reason,
any callable taking an `exception_type` must always return the same monad type as the
originating monad.
- If the monad is empty and the callable takes an `empty_type`, then call the callable,
else pass through the monad. For this reason, any callable with an `empty_type` parameter must
always return the same monad type as the originating monad.

Note that for nested monads e.g. monad<monad<int>>, either or both of the inner or outer
monads can be with value or with error or empty. You should have your binds and maps
work appropriately.

For maximum build performance, try to avoid bind() and map() as these use some hefty
metaprogramming to deduce what kind of bind and map you're doing based on the callables
passed. unwrap() is implemented using a recursively expanded structure which is probably
okay for low unwrap depths. then() is probably the least weighty of the monadic operators
as it's relatively dumb and the only metaprogramming is to determine whether to wrap
the return type with a monad or not.

### Acknowledgements ###
To T.C. on Stack Overflow for answering my question at https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference
and without whose excellent answer the intelligent map() and bind() above could not work.
*/
///@{
//! \brief If I am a monad<monad<...>>, return copy of most nested monad<...>, else return copy of *this
#ifdef DOXYGEN_IS_IN_THE_HOUSE
monad<...> unwrap() const &;
#else
BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_unwrap<monad>::output_type unwrap() const & { return detail::do_unwrap<monad>()(*this); }
#endif
//! \brief If I am a monad<monad<...>>, return move of most nested monad<...>, else return move of *this
#ifdef DOXYGEN_IS_IN_THE_HOUSE
monad<...> unwrap() &&;
#else
BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_unwrap<monad>::output_type unwrap() && { return detail::do_unwrap<monad>()(std::move(*this)); }
#endif

/*! \brief Return monad(F(*this)) or F(*this) if the latter returns a monad.

The callable F needs to consume a monad obviously enough, however if your callable takes a monad &&, you can move
from the monad. Equally, you can avoid copies if your
callable takes a reference argument. The callable F can be a generic lambda if desired.

If your callable does not return a monad, a monad will be constructed to hold the type it does return
inheriting the same error_code, exception_type etc of the originating monad. If your callable returns
a monad, that monad can be of any template parameter configuration and it will be returned from then(). This
allows a very easy way of converting between different configurations of monad cost free.
*/
#ifdef DOXYGEN_IS_IN_THE_HOUSE
template<class F> monad(F(*this)).unwrap() then(F &&f);
#else
template<class F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_then<typename traits::is_callable_is_well_formed<F, monad>::type, F, monad>::output_type then(F &&f)
{
typedef traits::callable_argument_traits<F, monad> f_traits;
static_assert(f_traits::valid,
"The callable passed to then() must take this monad type or a reference to it.");
return detail::do_then<typename f_traits::return_type, F, monad>(std::forward<F>(f))(std::move(*this), traits::detail::rank<5>());
}
#endif

//! \brief If bool(*this), return monad(F(get())).unwrap(), else return monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
template<class F> monad(F(get())).unwrap() bind(F &&f);
#else
template<class F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_bind<typename detail::bind_map_parameter_validation<F, monad>::return_type, F, monad>::output_type bind(F &&f)
{
typedef detail::do_bind<typename detail::bind_map_parameter_validation<F, monad>::return_type, F, monad> impl;
if(has_value())
return impl(std::forward<F>(f))(std::move(_storage.value), traits::detail::rank<5>());
else if(has_error())
return impl(std::forward<F>(f))(std::move(_storage.error), traits::detail::rank<5>());
else if(has_exception())
return impl(std::forward<F>(f))(std::move(_storage.exception), traits::detail::rank<5>());
else
return impl(std::forward<F>(f))(empty_type(), traits::detail::rank<5>());
}
#endif

//! \brief If bool(*this), return monad(F(get())), else return monad<result_of<F(get())>>(error)
#ifdef DOXYGEN_IS_IN_THE_HOUSE
template<class F> monad(F(get())) map(F &&f);
#else
template<class F> BOOST_SPINLOCK_FUTURE_MSVC_HELP typename detail::do_map<typename detail::bind_map_parameter_validation<F, monad>::return_type, F, monad>::output_type map(F &&f)
{
typedef detail::do_map<typename detail::bind_map_parameter_validation<F, monad>::return_type, F, monad> impl;
if(has_value())
return impl(std::forward<F>(f))(std::move(_storage.value), traits::detail::rank<5>());
else if(has_error())
return impl(std::forward<F>(f))(std::move(_storage.error), traits::detail::rank<5>());
else if(has_exception())
return impl(std::forward<F>(f))(std::move(_storage.exception), traits::detail::rank<5>());
else
return impl(std::forward<F>(f))(empty_type(), traits::detail::rank<5>());
}
#endif
///@}
};

template<class _error_type, class _exception_type, class throw_error> class monad<void, _error_type, _exception_type, throw_error>
{
static_assert(!std::is_same<_error_type, _error_type>::value, "monad<void> not implemented yet");
};

//! \brief Makes a monad from the type passed
template<class T> monad<T> make_monad(T &&v) { return monad<T>(std::forward<T>(v)); }
//! \brief Makes an errored monad of type T
template<class T> monad<T> make_monad(std::error_code v) { return monad<T>(std::move(v)); }
//! \brief Makes an excepted monad of type T
template<class T> monad<T> make_monad(std::exception_ptr v) { return monad<T>(std::move(v)); }
//! \brief Makes an empty monad of type T
template<class T> monad<T> make_monad() { return monad<T>(); }
}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
template<typename value_type, class error_type, class exception_type> inline void swap(BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad<value_type, error_type, exception_type> &a, BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::monad<value_type, error_type, exception_type> &b)
{
a.swap(b);
}
}

#endif
/* End /home/ned/boost.spinlock/include/boost/spinlock/monad.hpp */

/* Returning to /home/ned/boost.spinlock/include/boost/spinlock/future.hpp */

#include <future>

/*! \file future.hpp
\brief Provides a lightweight next generation future with N4399 Concurrency TS extensions

\headerfile include/boost/spinlock/future.hpp ""
*/

BOOST_SPINLOCK_V1_NAMESPACE_BEGIN
namespace lightweight_futures {

template<typename R, class _error_type=std::error_code, class _exception_type=std::exception_ptr> class promise;

namespace detail
{
template<class promise_type, class future_type> struct lock_guard
{
promise_type *_p;
future_type  *_f;
lock_guard(const lock_guard &)=delete;
lock_guard(lock_guard &&)=delete;
BOOST_SPINLOCK_FUTURE_MSVC_HELP lock_guard(promise_type *p) : _p(nullptr), _f(nullptr)
{
// constexpr fold
if(!p->_need_locks)
{
_p=p;
if(p->_storage.type==promise_type::value_storage_type::storage_type::future)
_f=p->_storage.future_;
return;
}
else for(;;)
{
p->_lock.lock();
if(p->_storage.type==promise_type::value_storage_type::storage_type::future)
{
if(p->_storage.future_->_lock.try_lock())
{
_p=p;
_f=p->_storage.future_;
break;
}
}
else
{
_p=p;
break;
}
p->_lock.unlock();
}
}
BOOST_SPINLOCK_FUTURE_MSVC_HELP lock_guard(future_type *f) : _p(nullptr), _f(nullptr)
{
// constexpr fold
if(!f->_need_locks)
{
_p=f->_promise;
_f=f;
return;
}
else for(;;)
{
f->_lock.lock();
if(f->_promise)
{
if(f->_promise->_lock.try_lock())
{
_p=f->_promise;
_f=f;
break;
}
}
else
{
_f=f;
break;
}
f->_lock.unlock();
}
}
BOOST_SPINLOCK_FUTURE_MSVC_HELP ~lock_guard()
{
unlock();
}
void unlock()
{
if(_p)
{
if(_p->_need_locks)
_p->_lock.unlock();
_p=nullptr;
}
if(_f)
{
if(_f->_need_locks)
_f->_lock.unlock();
_f=nullptr;
}
}
};

struct throw_future_promise_error
{
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR throw_future_promise_error(monad_errc ec)
{
switch(ec)
{
case monad_errc::already_set:
throw std::future_error(std::future_errc::promise_already_satisfied);
case monad_errc::no_state:
throw std::future_error(std::future_errc::no_state);
default:
abort();
}
}
};
}

template<typename R, class _error_type, class _exception_type> class promise
{
public:
typedef R value_type;
typedef _error_type error_type;
typedef _exception_type exception_type;
typedef future<value_type, error_type, exception_type> future_type;
friend class future<value_type, error_type, exception_type>;
friend struct detail::lock_guard<promise, future_type>;
private:
typedef detail::value_storage<value_type, error_type, exception_type, detail::throw_future_promise_error> value_storage_type;
value_storage_type _storage;
bool _need_locks;                 // Used to inhibit unnecessary atomic use, thus enabling constexpr collapse
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4624)
#endif
union { spinlock<bool> _lock; };  // Delay construction
#ifdef _MSC_VER
#pragma warning(pop)
#endif
public:
//! \brief EXTENSION: constexpr capable constructor
BOOST_SPINLOCK_FUTURE_CONSTEXPR promise() : _need_locks(false)
{
static_assert(std::is_move_constructible<value_type>::value, "Type must be move constructible to be used in a lightweight promise");
}
// template<class Allocator> promise(allocator_arg_t, Allocator a); // cannot support
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR promise(promise &&o) noexcept(std::is_nothrow_move_constructible<value_storage_type>::value) : _need_locks(o._need_locks)
{
if(_need_locks) new (&_lock) spinlock<bool>();
detail::lock_guard<promise, future_type> h(&o);
_storage=std::move(o._storage);
if(h._f)
h._f->_promise=this;
}
promise &operator=(promise &&o) noexcept(std::is_nothrow_move_constructible<value_storage_type>::value)
{
// TODO FIXME: Only safe if both of these are noexcept
this->~promise();
new (this) promise(std::move(o));
return *this;
}
promise(const promise &)=delete;
promise &operator=(const promise &)=delete;
BOOST_SPINLOCK_FUTURE_MSVC_HELP ~promise() noexcept(std::is_nothrow_destructible<value_storage_type>::value)
{
detail::lock_guard<promise, future_type> h(this);
if(h._f)
{
if(!h._f->is_ready())
h._f->set_exception(make_exception_ptr(std::future_error(std::future_errc::broken_promise)));
h._f->_promise=nullptr;
}
// Destroy myself before locks exit
_storage.clear();
}

void swap(promise &o) noexcept(std::is_nothrow_move_constructible<value_storage_type>::value)
{
detail::lock_guard<promise, future_type> h1(this), h2(&o);
_storage.swap(o._storage);
if(h1._f)
h1._f->_promise=&o;
if(h2._f)
h2._f->_promise=this;
}

BOOST_SPINLOCK_FUTURE_MSVC_HELP future_type get_future()
{
// If no value stored yet, I need locks on from now on
if(!_need_locks && _storage.type==value_storage_type::storage_type::empty)
{
_need_locks=true;
new (&_lock) spinlock<bool>();
}
detail::lock_guard<promise, future_type> h(this);
if(h._f)
throw std::future_error(std::future_errc::future_already_retrieved);
future_type ret(this);
h.unlock();
return ret;
}
//! \brief EXTENSION: Does this promise have a future?
bool has_future() const noexcept
{
//detail::lock_guard<value_type> h(this);
return _storage.type==value_storage_type::storage_type::future;
}

BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(const value_type &v) noexcept(std::is_nothrow_copy_constructible<value_type>::value)
{
detail::lock_guard<promise, future_type> h(this);
if(h._f)
h._f->set_value(v);
else
_storage.set_value(v);
}
BOOST_SPINLOCK_FUTURE_MSVC_HELP void set_value(value_type &&v) noexcept(std::is_nothrow_move_constructible<value_type>::value)
{
detail::lock_guard<promise, future_type> h(this);
if(h._f)
h._f->set_value(std::move(v));
else
_storage.set_value(std::move(v));
}
//! \brief EXTENSION: Set an error code (doesn't allocate)
void set_error(error_type e) noexcept(std::is_nothrow_copy_constructible<error_type>::value)
{
detail::lock_guard<promise, future_type> h(this);
if(h._f)
h._f->set_error(e);
else
_storage.set_error(e);
}
void set_exception(exception_type e) noexcept(std::is_nothrow_copy_constructible<exception_type>::value)
{
detail::lock_guard<promise, future_type> h(this);
if(h._f)
h._f->set_exception(e);
else
_storage.set_exception(e);
}
template<typename E> void set_exception(E &&e)
{
set_exception(make_exception_ptr(std::forward<E>(e)));
}

// Not supported right now
// void set_value_at_thread_exit(R v);
// void set_exception_at_thread_exit(R v);

//! \brief Call F when the future signals, consuming the future. Only one of these may be set.
// template<class F> typename std::result_of<F(future<value_type>)>::type then(F &&f);

//! \brief Call F when the future signals, not consuming the future.
// template<class F> typename std::result_of<F(future<const value_type &>)>::type then(F &&f);
};

// TODO: promise<void>, promise<R&> specialisations
// TODO: future<void>, future<R&> specialisations

/*! \class future
\brief Lightweight next generation future with N4399 Concurrency TS extensions

http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4399.html
*/
template<typename R, class _error_type, class _exception_type> class future : protected monad<R, _error_type, _exception_type, detail::throw_future_promise_error>
{
typedef monad<R, _error_type, _exception_type, detail::throw_future_promise_error> monad_type;
public:
typedef typename monad_type::value_type value_type;
typedef typename monad_type::error_type error_type;
typedef typename monad_type::exception_type exception_type;
BOOST_STATIC_CONSTEXPR bool is_consuming=true;
typedef promise<value_type, error_type, exception_type> promise_type;
friend class promise<value_type, error_type, exception_type>;
friend struct detail::lock_guard<promise_type, future>;
private:
bool _need_locks;                 // Used to inhibit unnecessary atomic use, thus enabling constexpr collapse
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4624)
#endif
union { spinlock<bool> _lock; };  // Delay construction
#ifdef _MSC_VER
#pragma warning(pop)
#endif
promise_type *_promise;
protected:
// Called by promise::get_future(), so currently thread safe
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR future(promise_type *p) : monad_type(std::move(p->_storage)), _need_locks(p->_need_locks), _promise(p)
{
if(_need_locks) new (&_lock) spinlock<bool>();
p->_storage.set_future(this);
}
public:
//! \brief EXTENSION: constexpr capable constructor
BOOST_SPINLOCK_FUTURE_CONSTEXPR future() : _need_locks(false), _promise(nullptr)
{
static_assert(std::is_move_constructible<value_type>::value, "Type must be move constructible to be used in a lightweight future");
}
BOOST_SPINLOCK_FUTURE_CXX14_CONSTEXPR future(future &&o) noexcept(std::is_nothrow_move_constructible<monad_type>::value) : _need_locks(o._need_locks), _promise(nullptr)
{
if(_need_locks) new (&_lock) spinlock<bool>();
detail::lock_guard<promise_type, future> h(&o);
new(this) monad_type(std::move(o));
if(o._promise)
{
_promise=o._promise;
o._promise=nullptr;
if(h._p)
h._p->_storage.future_=this;
}
}
future &operator=(future &&o) noexcept(std::is_nothrow_move_constructible<monad_type>::value)
{
// TODO FIXME: Only safe if both of these are noexcept
this->~future();
new (this) future(std::move(o));
return *this;
}
future(const future &)=delete;
future &operator=(const future &)=delete;
// MSVC needs the destructor force inlined to do the right thing for some reason
BOOST_SPINLOCK_FUTURE_MSVC_HELP ~future() noexcept(std::is_nothrow_destructible<monad_type>::value)
{
detail::lock_guard<promise_type, future> h(this);
if(h._p)
h._p->_storage.clear();
// Destroy myself before locks exit
monad_type::clear();
}

void swap(future &o) noexcept(std::is_nothrow_move_constructible<monad_type>::value)
{
detail::lock_guard<promise_type, future> h1(this), h2(&o);
monad_type::swap(o._storage);
if(h1._p)
h1._p->_storage.future_=&o;
if(h2._p)
h2._p->_storage.future_=this;
}

// shared_future<value_type> share();  // TODO

BOOST_SPINLOCK_FUTURE_MSVC_HELP value_type get()
{
wait();
detail::lock_guard<promise_type, future> h(this);
value_type ret(std::move(*this).value());
monad_type::clear();
if(h._p)
h._p->_storage.clear();
if(h._f)
h._f->_promise=nullptr;
return std::move(ret);
}
// value_type get_or(const value_type &);  // TODO
// value_type get_or(value_type &&);  // TODO
error_type get_error()
{
wait();
detail::lock_guard<promise_type, future> h(this);
error_type e(monad_type::error());
if (!e)
return std::move(e);
monad_type::clear();
if (h._p)
h._p->_storage.clear();
if (h._f)
h._f->_promise = nullptr;
return std::move(e);
}
exception_type get_exception()
{
wait();
detail::lock_guard<promise_type, future> h(this);
exception_type e(monad_type::get_exception());
if(!e)
return std::move(e);
monad_type::clear();
if(h._p)
h._p->_storage.clear();
if(h._f)
h._f->_promise=nullptr;
return std::move(e);
}
// Compatibility with Boost.Thread
exception_type get_exception_ptr() { return get_exception(); }

bool valid() const noexcept
{
return !!_promise;
}
using monad_type::is_ready;
using monad_type::has_value;
using monad_type::has_error;
using monad_type::has_exception;

void wait() const
{
if(!valid())
throw std::future_error(std::future_errc::no_state);
// TODO Actually sleep
while(!monad_type::is_ready())
{
}
}
// template<class R, class P> future_status wait_for(const std::chrono::duration<R, P> &rel_time) const;  // TODO
// template<class C, class D> future_status wait_until(const std::chrono::time_point<C, D> &abs_time) const;  // TODO

// TODO Where F would return a future<future<...>>, we unwrap to a single future<R>
// template<class F> typename std::result_of<F(future)>::type then(F &&f);
};

template<typename R> inline future<typename std::decay<R>::type> make_ready_future(R &&v)
{
return future<typename std::decay<R>::type>(std::forward<R>(v));
}
template<typename R> inline future<R> make_errored_future(std::error_code v)
{
return future<R>(v);
}
template<typename R> inline future<R> make_exceptional_future(std::exception_ptr v)
{
return future<R>(v);
}

// TODO
// template<class InputIterator> ? when_all(InputIterator first, InputIterator last);
// template<class... Futures> ? when_all(Futures &&... futures);
// template<class Sequence> struct when_any_result;
// template<class InputIterator> ? when_any(InputIterator first, InputIterator last);
// template<class... Futures> ? when_any(Futures &&... futures);

// TODO packaged_task

#ifdef _MSC_VER
#undef value
#undef exception
#undef error
#undef future_
#endif

}
BOOST_SPINLOCK_V1_NAMESPACE_END

namespace std
{
template<typename R> inline void swap(BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::promise<R> &a, BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::promise<R> &b)
{
a.swap(b);
}
template<typename R> inline void swap(BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::future<R> &a, BOOST_SPINLOCK_V1_NAMESPACE::lightweight_futures::future<R> &b)
{
a.swap(b);
}
}

#endif
/* End /home/ned/boost.spinlock/include/boost/spinlock/future.hpp */

/* END OF AUTOMATICALLY GENERATED FILE */

